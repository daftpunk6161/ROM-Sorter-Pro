# -*-coding: utf-8-*-
"""ROM SORTER PRO - DEPRECATED: Optimized File Scanner V2.1.8 Caution: this modules is deprecated and will be removed in future versions. Please use the new scanner module in SRC.Scanning Instead. Performance Optimizations V2.1.8: - High-performance Threading for Large Directory Structures - Intelligent caching with adaptive adaptation - Adaptive Batch Processing for optimal throughout - Depth-Limited Recursion for Faster Search - Adaptive settings Based on File System Performance - Optimized Memory Usage for Large Directories Project: Rome Sorter Pro File: SRC/Optimized_Scanner.py Version: 2.1.8 Author: Cemal / Daftpunk6161 License: with license Python: 3.8+"""

import os
import re
import time
import threading
import logging
import warnings
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
from functools import lru_cache

# Provide warning - with improved performance through delayed import strategy
warnings.warn(
    "Das Modul optimized_scanner.py ist veraltet und wird in zukÃ¼nftigen Versionen entfernt. "
    "Bitte verwenden Sie stattdessen die Module in src.scanning.",
    DeprecationWarning, stacklevel=2
)

# Logger Setup With Efficient Zero Handler AS A Default
logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# Optimized import strategy - imports only if necessary
# Use Lazy Loading and Caching for Imports
_imports = {
    'scanner': None,
    'compat': None
}

def _get_module(name):
    """Only loads a module if necessary"""
    global _imports
    if _imports[name] is None:
        try:
            if name == 'scanner':
# Relative import within the scanning package
                from . import adaptive_scanner
                _imports[name] = adaptive_scanner
            elif name == 'compat':
# Import of the compatibility module
                from ..utils import scanner_compat
                _imports[name] = scanner_compat
        except ImportError as e:
            logger.error(f"Fehler beim Importieren von {name}: {e}")
            raise
    return _imports[name]

# Simple wrapper functions for API compatibility
def scan_directory(directory: str, progress_callback=None, stop_event=None, use_cache=True) -> List[Path]:
    """Scan a list of Rome files. This function is outdated and delegated to the new adaptive scanner. Args: Directory: Directory to be searched Progress_Callback: Callback function for progress Stop_event: Event to stop the scan use_cache: Whether the cache should be used Return: List of ROM file paths"""
    compat = _get_module('compat')
    return compat.scan_directory(directory, progress_callback, stop_event, use_cache)

def clear_cache():
    """Deletes the scan cache (delegates to adaptive scanners)."""
    compat = _get_module('compat')
    compat.clear_cache()

def get_cache_stats():
    """Gives back statistics to the cache. Return: Dict with cache statistics"""
    compat = _get_module('compat')
    return compat.get_cache_stats()

class OptimizedFileScanner:
    """Outdated optimized files scanner class. This class is just a wrapper for the new adaptive scanner class in SRC.Scanning. It will be removed in future versions."""

# Lightweight class attributes with delegate patterns
    _cache_lock = threading.RLock()
    _settings = {
        'use_threading': os.cpu_count() and os.cpu_count() > 2,
        'max_threads': max(1, min(8, (os.cpu_count() or 4) // 2)),
        'min_files_for_threading': 1000,
        'batch_size_base': 100,
        'cache_ttl': 300,
        'max_cache_entries': 10,
        'skip_hidden_dirs': True,
        'skip_system_dirs': True,
        'max_scan_depth': 20,
    }

# Lightweight performance metrics (are not really used)
    _performance_metrics = {
        'last_scan_time': 0,
        'last_files_per_second': 0,
        'filesystem_latency': 0.001,
    }

    def __init__(self, extensions=None):
        """Initialize the scanner with optional extension filter."""
        compat = _get_module('compat')

# Direct delegation to optimized files from compat
        self._delegate = compat.OptimizedFileScanner(extensions)

# Lightweight statistics for API compatibility
        self.stats = {
            'hidden_dirs_skipped': 0,
            'hidden_files_skipped': 0,
            'unsupported_files_skipped': 0,
            'dirs_processed': 0,
            'cached_results_used': 0
        }

# Optimized extension test with LRU_Cache
        self.ROM_EXTENSIONS = set(ext.lower() for ext in extensions) if extensions else set()
        self._is_rom_file = lru_cache(maxsize=2048)(self._optimized_extension_check)

    def _optimized_extension_check(self, path):
        """Optimized check for ROM date eggs with delegation."""
        try:
            return self._delegate._real_scanner._is_valid_extension(path)
        except (AttributeError, TypeError):
# Fallback in the event that the delegation fails
            ext = path.suffix.lower()
            return ext.lstrip('.') in self.ROM_EXTENSIONS if self.ROM_EXTENSIONS else True

    def scan_directory(self, directory: str, progress_callback=None, stop_event=None, use_cache=True) -> List[Path]:
        """Scans the directory of Rome files with optimal performance and adaptive adaptation. Args: Directory: Directory to be searched Progress_Callback: Callback function for progress Stop_event: Event to stop the scan use_cache: Whether the cache should be used Return: List of ROM file paths"""
        try:
# Efficient delegation to the real scanner
            return self._delegate.scan_directory(directory, progress_callback, stop_event, use_cache)
        except Exception as e:
            logger.error(f"Fehler beim Scannen von {directory}: {e}")
            return []

# Methods for maintaining API compatibility (empty implementations)
    def _measure_filesystem_performance(self, directory):
        """Delegiert an AdaptiveScanner (leere Implementierung)."""
        pass

    def _should_use_threading(self, directory):
        """Delegiert an AdaptiveScanner (leere Implementierung)."""
        return False

    def _scan_sequential(self, directory, progress_callback=None):
        """Delegiert an AdaptiveScanner (leere Implementierung)."""
        return self.scan_directory(directory, progress_callback)

    def _scan_with_threading(self, directory, progress_callback=None):
        """Delegiert an AdaptiveScanner (leere Implementierung)."""
        return self.scan_directory(directory, progress_callback)

    def _thread_scan_worker(self, dirs, thread_id, progress_callback):
        """Delegiert an AdaptiveScanner (leere Implementierung)."""
        pass

    def _create_balanced_dir_chunks(self, dirs, num_chunks):
        """Delegiert an AdaptiveScanner (leere Implementierung)."""
        return [dirs]

    def _adjust_adaptive_parameters(self, files_per_second, dirs_scanned, total_time):
        """Delegiert an AdaptiveScanner (leere Implementierung)."""
        pass

    @classmethod
    def clear_cache(cls):
        """Deletes the scanner cache."""
        compat = _get_module('compat')
        compat.clear_cache()

    @property
    def cache_stats(self):
        """Gives back cache statistics. Return: Dict with cache statistics"""
        compat = _get_module('compat')
        return compat.get_cache_stats()
