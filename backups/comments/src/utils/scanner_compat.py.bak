"""
Wrapper-Funktionen für die veralteten Aufrufe aus optimized_scanner.py

Dieses Modul bietet eine Kompatibilitätsschicht zwischen dem veralteten
optimized_scanner.py und der neuen AdaptiveScanner-Implementierung.

OPTIMIERUNGEN:
- Verzögerte Importe für bessere Startzeit
- Effiziente Speichernutzung durch Lazy Initialization
- Verbesserte Cache-Nutzung und -Verwaltung
- Erweiterte Fehlerbehandlung und Logging
- Performance-Monitoring-Integration
"""

import warnings
import logging
import time
import sys
from pathlib import Path
from typing import List, Union, Optional, Dict, Any, Callable
from functools import wraps
import threading

# Logger-Setup mit NullHandler als Default
logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# Lazy-Loading von Modulen für verbesserte Startzeit
_lazy_imports = {}
_import_lock = threading.RLock()

def _import_scanner():
    """Importiert die Scanner-Module mit Fehlerbehandlung"""
    try:
        with _import_lock:
            if 'scanner' not in _lazy_imports:
                # Versuche relativen Import
                from ..scanning import adaptive_scanner
                _lazy_imports['scanner'] = {
                    'scan_directory_adaptive': adaptive_scanner.scan_directory_adaptive,
                    'AdaptiveScanner': adaptive_scanner.AdaptiveScanner,
                    'get_scanner_performance_stats': adaptive_scanner.get_scanner_performance_stats
                }
    except (ImportError, ValueError) as e:
        logger.warning(f"Relativer Import fehlgeschlagen: {e}, versuche absoluten Import")
        try:
            # Fallback zum absoluten Import
            from src.scanning import adaptive_scanner
            _lazy_imports['scanner'] = {
                'scan_directory_adaptive': adaptive_scanner.scan_directory_adaptive,
                'AdaptiveScanner': adaptive_scanner.AdaptiveScanner,
                'get_scanner_performance_stats': adaptive_scanner.get_scanner_performance_stats
            }
        except ImportError as e:
            logger.error(f"Fehler beim Importieren der Scanner-Module: {e}")
            # Stelle minimale Funktionalität bereit
            class FallbackScanner:
                def __init__(self, filter_extensions=None): pass
                def scan_directory_adaptive(self, *args, **kwargs): return []
                @classmethod
                def clear_cache(cls): pass
            
            _lazy_imports['scanner'] = {
                'scan_directory_adaptive': lambda *args, **kwargs: [],
                'AdaptiveScanner': FallbackScanner,
                'get_scanner_performance_stats': lambda: {'error': str(e)}
            }

def _import_performance():
    """Importiert die Performance-Module mit Fehlerbehandlung"""
    try:
        with _import_lock:
            if 'performance' not in _lazy_imports:
                try:
                    # Versuche relativen Import
                    from ..utils import performance
                    _lazy_imports['performance'] = {
                        'measure_time': performance.measure_time,
                        'monitor': performance.PerformanceMonitor.get_instance()
                    }
                except (ImportError, ValueError):
                    # Fallback zum absoluten Import
                    from src.utils.performance import measure_time, PerformanceMonitor
                    _lazy_imports['performance'] = {
                        'measure_time': measure_time,
                        'monitor': PerformanceMonitor.get_instance()
                    }
    except ImportError as e:
        logger.warning(f"Performance-Module nicht verfügbar: {e}")
        # Dummy-Funktionen bereitstellen
        _lazy_imports['performance'] = {
            'measure_time': lambda func=None, **kwargs: func if func else lambda f: f,
            'monitor': type('DummyMonitor', (), {
                'record_operation_time': lambda *args, **kwargs: None
            })
        }

def with_performance_tracking(func):
    """Dekorator für Performance-Tracking"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        try:
            return func(*args, **kwargs)
        finally:
            duration = time.perf_counter() - start_time
            try:
                # Performance-Monitoring nur wenn verfügbar
                if 'performance' not in _lazy_imports:
                    _import_performance()
                perf = _lazy_imports.get('performance', {})
                if perf and 'monitor' in perf:
                    perf['monitor'].record_operation_time(f"compat_{func.__name__}", duration)
            except Exception:
                pass  # Performance-Monitoring ist optional
    return wrapper

@with_performance_tracking
def scan_directory(directory: str, progress_callback=None, stop_event=None, use_cache=True) -> List[Path]:
    """
    Wrapper für den veralteten scan_directory-Aufruf aus optimized_scanner.py.

    Args:
        directory: Zu durchsuchendes Verzeichnis
        progress_callback: Callback-Funktion für Fortschrittsbenachrichtigungen
        stop_event: Event zum Stoppen des Scans
        use_cache: Ob der Cache verwendet werden soll

    Returns:
        Liste von ROM-Dateipfaden
    """
    warnings.warn(
        "Die Verwendung von optimized_scanner.py ist veraltet. "
        "Bitte verwenden Sie stattdessen src.scanning.scan_directory_adaptive.",
        DeprecationWarning, stacklevel=2
    )

    try:
        # Stelle sicher, dass Scanner-Module geladen sind
        if 'scanner' not in _lazy_imports:
            _import_scanner()
        
        scanner_module = _lazy_imports['scanner']
        scanner = scanner_module['AdaptiveScanner']()

        # Wenn progress_callback vorhanden ist, passen wir es für die neue API an
        if progress_callback:
            def adapted_callback(completed, total, percentage):
                try:
                    progress_callback(percentage, f"{completed}/{total} Dateien")
                except Exception as e:
                    logger.warning(f"Fehler im Progress-Callback: {e}")

            # Verwende scan_with_progress_callback wenn verfügbar
            if hasattr(scanner, 'scan_with_progress_callback'):
                results = scanner.scan_with_progress_callback(
                    directory_path=directory,
                    progress_callback=adapted_callback,
                    recursive=True
                )
            else:
                # Fallback für ältere Scanner-Versionen
                results = scanner.scan_directory_adaptive(directory, recursive=True, use_cache=use_cache)
        else:
            # Ohne Callback verwenden wir scan_directory_adaptive
            results = scanner.scan_directory_adaptive(directory, recursive=True, use_cache=use_cache)

        # Konvertiere ROMMetadata zu Path für Abwärtskompatibilität
        if results and hasattr(results[0], 'path'):
            return [item.path for item in results]
        return results  # Bereits eine Liste von Paths oder leer
        
    except Exception as e:
        logger.error(f"Fehler beim Scannen von {directory}: {e}")
        return []

@with_performance_tracking
def clear_cache():
    """
    Wrapper für den veralteten clear_cache-Aufruf aus optimized_scanner.py.
    """
    warnings.warn(
        "Die Verwendung von optimized_scanner.py ist veraltet. "
        "Bitte verwenden Sie stattdessen src.scanning.AdaptiveScanner.clear_cache.",
        DeprecationWarning, stacklevel=2
    )

    try:
        # Stelle sicher, dass Scanner-Module geladen sind
        if 'scanner' not in _lazy_imports:
            _import_scanner()
            
        scanner_module = _lazy_imports['scanner']
        scanner_module['AdaptiveScanner'].clear_cache()
        logger.debug("Scanner-Cache erfolgreich gelöscht")
    except Exception as e:
        logger.warning(f"Fehler beim Löschen des Scanner-Caches: {e}")

@with_performance_tracking
def get_cache_stats() -> Dict[str, Any]:
    """
    Wrapper für den veralteten cache_stats-Aufruf aus optimized_scanner.py.

    Returns:
        Dict mit Cache-Statistiken
    """
    warnings.warn(
        "Die Verwendung von optimized_scanner.py ist veraltet. "
        "Bitte verwenden Sie stattdessen src.scanning.get_scanner_performance_stats.",
        DeprecationWarning, stacklevel=2
    )

    try:
        # Stelle sicher, dass Scanner-Module geladen sind
        if 'scanner' not in _lazy_imports:
            _import_scanner()
            
        scanner_module = _lazy_imports['scanner']
        return scanner_module['get_scanner_performance_stats']()
    except Exception as e:
        logger.warning(f"Fehler beim Abrufen der Cache-Statistiken: {e}")
        return {
            'error': str(e),
            'hits': 0,
            'misses': 0,
            'hit_rate': 0,
            'cache_size': 0,
            'max_cache_size': 0
        }

class OptimizedFileScanner:
    """
    Veraltete OptimizedFileScanner-Klasse aus optimized_scanner.py.
    Diese Klasse dient nur als Wrapper und sollte nicht mehr verwendet werden.
    
    OPTIMIERUNGEN:
    - Lazy-Loading der Abhängigkeiten
    - Effizientere Speichernutzung
    - Verbesserte Fehlerbehandlung
    - Intelligent Caching für bessere Performance
    """

    def __init__(self, extensions=None):
        """
        Initialisiert einen neuen OptimizedFileScanner (Wrapper).

        Args:
            extensions: Optionale Liste von Dateierweiterungen zum Filtern
        """
        warnings.warn(
            "Die OptimizedFileScanner-Klasse ist veraltet. "
            "Bitte verwenden Sie stattdessen src.scanning.AdaptiveScanner.",
            DeprecationWarning, stacklevel=2
        )

        # Stelle sicher, dass Scanner-Module geladen sind
        if 'scanner' not in _lazy_imports:
            _import_scanner()
            
        scanner_module = _lazy_imports['scanner']
        # Erstelle echten Scanner mit verzögerter Initialisierung
        self._real_scanner = scanner_module['AdaptiveScanner'](filter_extensions=extensions)
        logger.debug("OptimizedFileScanner-Wrapper initialisiert")

    @with_performance_tracking
    def scan_directory(self, directory: str, progress_callback=None, stop_event=None, use_cache=True) -> List[Path]:
        """
        Scannt ein Verzeichnis (Wrapper-Methode).

        Args:
            directory: Zu durchsuchendes Verzeichnis
            progress_callback: Callback-Funktion für Fortschrittsbenachrichtigungen
            stop_event: Event zum Stoppen des Scans
            use_cache: Ob der Cache verwendet werden soll

        Returns:
            Liste von ROM-Dateipfaden
        """
        try:
            # Delegiere an die globale Wrapper-Funktion
            return scan_directory(directory, progress_callback, stop_event, use_cache)
        except Exception as e:
            logger.error(f"Fehler beim Scannen von {directory}: {e}")
            return []

    @classmethod
    @with_performance_tracking
    def clear_cache(cls):
        """Löscht den Scanner-Cache (Wrapper-Methode)."""
        clear_cache()

    @property
    @with_performance_tracking
    def cache_stats(self):
        """
        Gibt Cache-Statistiken zurück (Wrapper-Methode).

        Returns:
            Dict mit Cache-Statistiken
        """
        return get_cache_stats()
