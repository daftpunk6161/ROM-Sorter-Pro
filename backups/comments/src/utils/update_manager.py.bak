#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ROM Sorter Pro - Automatische Update Manager

Dieses Modul implementiert einen automatischen Update-Manager, der nach Updates
sucht, diese herunterlädt und installiert. Es unterstützt die Aktualisierung von
Programmdateien, Datenbanken und anderen Ressourcen.

Features:
- Automatische Überprüfung auf Updates
- Sicheres Herunterladen und Verifizieren von Updates
- Wiederherstellungsmechanismen bei fehlgeschlagenen Updates
- Inkrementelle Updates zur Bandbreitenoptimierung
"""

import os
import re
import sys
import json
import time
import hashlib
import logging
import requests
import tempfile
import shutil
import threading
import platform
import subprocess
from typing import Dict, List, Any, Tuple, Optional, Union, Set, Callable
from datetime import datetime, timedelta
from pathlib import Path

# Logger konfigurieren
logger = logging.getLogger(__name__)

# Update-Server-URL
UPDATE_SERVER = "https://romsorter.example.com/updates"

# Update-Konfigurationsdatei
UPDATE_CONFIG_FILE = os.path.join(os.path.dirname(__file__), '..', '..', 'config', 'update.json')

# Version des Programms
VERSION_FILE = os.path.join(os.path.dirname(__file__), '..', '..', 'version.txt')

# Pfad für temporäre Update-Dateien
TEMP_UPDATE_DIR = os.path.join(tempfile.gettempdir(), "romsorter_updates")


class UpdateError(Exception):
    """Basisklasse für Update-Fehler."""
    pass


class UpdateManager:
    """
    Verwaltet den Update-Prozess für ROM Sorter Pro.
    """

    def __init__(self, auto_check: bool = True, check_interval: int = 24):
        """
        Initialisiert den Update-Manager.

        Args:
            auto_check: Automatische Update-Prüfung aktivieren
            check_interval: Prüfintervall in Stunden
        """
        self.auto_check = auto_check
        self.check_interval = check_interval
        self.current_version = self._get_current_version()
        self.update_config = self._load_update_config()
        self.update_thread = None
        self.is_checking = False
        self.last_check_time = None
        self.update_available = False
        self.available_version = None
        self.update_info = None
        self.update_progress_callback = None

        # Stelle sicher, dass das temporäre Update-Verzeichnis existiert
        os.makedirs(TEMP_UPDATE_DIR, exist_ok=True)

        # Starte automatische Prüfung, falls aktiviert
        if self.auto_check:
            self._start_auto_check()

    def _get_current_version(self) -> str:
        """
        Ermittelt die aktuelle Version des Programms.

        Returns:
            Aktuelle Version als String
        """
        try:
            if os.path.exists(VERSION_FILE):
                with open(VERSION_FILE, 'r') as f:
                    version = f.read().strip()
                return version
            else:
                # Standardversion, falls keine Versionsdatei gefunden wurde
                return "0.0.1"
        except Exception as e:
            logger.error(f"Fehler beim Lesen der Versionsdatei: {e}")
            return "0.0.1"

    def _load_update_config(self) -> Dict[str, Any]:
        """
        Lädt die Update-Konfiguration aus der Datei.

        Returns:
            Update-Konfiguration als Dictionary
        """
        default_config = {
            "auto_check": self.auto_check,
            "check_interval": self.check_interval,
            "last_check": None,
            "update_channel": "stable",
            "proxy": None,
            "custom_update_server": None
        }

        try:
            if os.path.exists(UPDATE_CONFIG_FILE):
                with open(UPDATE_CONFIG_FILE, 'r') as f:
                    config = json.load(f)

                # Ergänze fehlende Einträge mit Standardwerten
                for key, value in default_config.items():
                    if key not in config:
                        config[key] = value

                return config
            else:
                # Erstelle die Konfigurationsdatei mit Standardwerten
                os.makedirs(os.path.dirname(UPDATE_CONFIG_FILE), exist_ok=True)
                with open(UPDATE_CONFIG_FILE, 'w') as f:
                    json.dump(default_config, f, indent=2)

                return default_config
        except Exception as e:
            logger.error(f"Fehler beim Laden der Update-Konfiguration: {e}")
            return default_config

    def _save_update_config(self) -> bool:
        """
        Speichert die Update-Konfiguration in die Datei.

        Returns:
            True bei Erfolg, False bei Fehler
        """
        try:
            os.makedirs(os.path.dirname(UPDATE_CONFIG_FILE), exist_ok=True)
            with open(UPDATE_CONFIG_FILE, 'w') as f:
                json.dump(self.update_config, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Fehler beim Speichern der Update-Konfiguration: {e}")
            return False

    def _start_auto_check(self) -> None:
        """Startet die automatische Update-Prüfung."""
        def check_thread():
            while self.auto_check:
                # Prüfe, ob eine Update-Prüfung erforderlich ist
                if self.update_config["last_check"] is None:
                    perform_check = True
                else:
                    last_check = datetime.fromisoformat(self.update_config["last_check"])
                    time_since_last_check = datetime.now() - last_check
                    perform_check = time_since_last_check > timedelta(hours=self.check_interval)

                if perform_check and not self.is_checking:
                    self.check_for_updates()

                # Warte für eine Stunde, bevor erneut geprüft wird
                time.sleep(3600)

        self.update_thread = threading.Thread(target=check_thread)
        self.update_thread.daemon = True
        self.update_thread.start()

    def set_progress_callback(self, callback: Callable[[int, str], None]) -> None:
        """
        Setzt einen Callback für Update-Fortschritt.

        Args:
            callback: Funktion, die bei Fortschritt aufgerufen wird
                     Signatur: callback(progress, message)
        """
        self.update_progress_callback = callback

    def _report_progress(self, progress: int, message: str) -> None:
        """
        Meldet den Update-Fortschritt.

        Args:
            progress: Fortschritt in Prozent (0-100)
            message: Fortschrittsmeldung
        """
        logger.debug(f"Update-Fortschritt {progress}%: {message}")

        if self.update_progress_callback:
            self.update_progress_callback(progress, message)

    def check_for_updates(self) -> bool:
        """
        Prüft, ob Updates verfügbar sind.

        Returns:
            True, wenn Updates verfügbar sind, sonst False
        """
        if self.is_checking:
            logger.warning("Update-Prüfung läuft bereits")
            return False

        self.is_checking = True
        self._report_progress(0, "Prüfe auf Updates...")

        try:
            # Bestimme die zu verwendende Update-Server-URL
            server_url = self.update_config.get("custom_update_server") or UPDATE_SERVER
            update_channel = self.update_config.get("update_channel", "stable")

            # Erstelle die URL für die Update-Prüfung
            url = f"{server_url}/check?version={self.current_version}&channel={update_channel}"

            # Konfiguriere den Proxy, falls vorhanden
            proxies = None
            if self.update_config.get("proxy"):
                proxies = {"http": self.update_config["proxy"], "https": self.update_config["proxy"]}

            # Führe die Anfrage aus
            self._report_progress(20, "Verbindung zum Update-Server wird hergestellt...")
            response = requests.get(url, proxies=proxies, timeout=30)

            if response.status_code == 200:
                data = response.json()
                self.update_available = data.get("update_available", False)

                if self.update_available:
                    self.available_version = data.get("version")
                    self.update_info = data
                    logger.info(f"Update verfügbar: Version {self.available_version}")
                    self._report_progress(100, f"Update auf Version {self.available_version} verfügbar!")
                else:
                    logger.info("Keine Updates verfügbar")
                    self._report_progress(100, "Die Software ist auf dem neuesten Stand")

                # Aktualisiere den Zeitpunkt der letzten Prüfung
                self.last_check_time = datetime.now()
                self.update_config["last_check"] = self.last_check_time.isoformat()
                self._save_update_config()

                self.is_checking = False
                return self.update_available
            else:
                logger.error(f"Fehler bei der Update-Prüfung: HTTP {response.status_code}")
                self._report_progress(100, f"Fehler bei der Update-Prüfung: HTTP {response.status_code}")
                self.is_checking = False
                return False

        except Exception as e:
            logger.error(f"Fehler bei der Update-Prüfung: {e}")
            self._report_progress(100, f"Fehler bei der Update-Prüfung: {e}")
            self.is_checking = False
            return False

    def download_update(self) -> Optional[str]:
        """
        Lädt das Update herunter.

        Returns:
            Pfad zur heruntergeladenen Update-Datei oder None bei Fehler
        """
        if not self.update_available or not self.update_info:
            logger.warning("Kein Update verfügbar")
            return None

        self._report_progress(0, "Update wird vorbereitet...")

        try:
            # Bestimme die zu verwendende Update-Server-URL
            server_url = self.update_config.get("custom_update_server") or UPDATE_SERVER

            # URL für den Download
            download_url = self.update_info.get("download_url")
            if not download_url:
                download_url = f"{server_url}/download?version={self.available_version}"

            # Prüfe, ob ein direkter Download-Link vorhanden ist
            if not download_url.startswith("http"):
                download_url = f"{server_url}/{download_url}"

            # Konfiguriere den Proxy, falls vorhanden
            proxies = None
            if self.update_config.get("proxy"):
                proxies = {"http": self.update_config["proxy"], "https": self.update_config["proxy"]}

            # Dateipfad für das heruntergeladene Update
            update_filename = f"romsorter_update_{self.available_version}.zip"
            update_filepath = os.path.join(TEMP_UPDATE_DIR, update_filename)

            # Lösche vorherige Update-Dateien
            if os.path.exists(update_filepath):
                os.remove(update_filepath)

            # Lade das Update herunter
            self._report_progress(10, "Update wird heruntergeladen...")

            with requests.get(download_url, proxies=proxies, stream=True, timeout=300) as r:
                r.raise_for_status()
                total_size = int(r.headers.get('content-length', 0))
                downloaded = 0

                with open(update_filepath, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)
                            downloaded += len(chunk)

                            # Berechne und melde den Fortschritt
                            if total_size > 0:
                                progress = int(10 + (downloaded / total_size) * 70)
                                self._report_progress(
                                    progress,
                                    f"Update wird heruntergeladen... {downloaded / 1024 / 1024:.1f} MB / {total_size / 1024 / 1024:.1f} MB"
                                )

            # Prüfe die Integrität des heruntergeladenen Updates
            if "checksum" in self.update_info:
                self._report_progress(80, "Überprüfe Update-Integrität...")

                checksum_type = self.update_info.get("checksum_type", "sha256")
                expected_checksum = self.update_info["checksum"]

                if not self._verify_checksum(update_filepath, expected_checksum, checksum_type):
                    logger.error("Checksum-Prüfung fehlgeschlagen")
                    self._report_progress(100, "Fehler: Update-Datei ist beschädigt")
                    return None

            self._report_progress(90, "Update erfolgreich heruntergeladen")
            return update_filepath

        except Exception as e:
            logger.error(f"Fehler beim Herunterladen des Updates: {e}")
            self._report_progress(100, f"Fehler beim Herunterladen des Updates: {e}")
            return None

    def _verify_checksum(self, file_path: str, expected_checksum: str,
                        checksum_type: str = "sha256") -> bool:
        """
        Überprüft die Integrität einer Datei mittels Checksum.

        Args:
            file_path: Pfad zur zu prüfenden Datei
            expected_checksum: Erwartete Checksum
            checksum_type: Typ der Checksum (md5, sha1, sha256, sha512)

        Returns:
            True, wenn die Checksum übereinstimmt, sonst False
        """
        try:
            if checksum_type == "md5":
                hasher = hashlib.md5()
            elif checksum_type == "sha1":
                hasher = hashlib.sha1()
            elif checksum_type == "sha256":
                hasher = hashlib.sha256()
            elif checksum_type == "sha512":
                hasher = hashlib.sha512()
            else:
                logger.warning(f"Unbekannter Checksum-Typ: {checksum_type}, verwende sha256")
                hasher = hashlib.sha256()

            with open(file_path, 'rb') as f:
                # Lese die Datei in Chunks, um den Speicherverbrauch zu begrenzen
                chunk_size = 4096
                for chunk in iter(lambda: f.read(chunk_size), b''):
                    hasher.update(chunk)

            calculated_checksum = hasher.hexdigest()

            logger.debug(f"Erwartete Checksum: {expected_checksum}")
            logger.debug(f"Berechnete Checksum: {calculated_checksum}")

            return calculated_checksum.lower() == expected_checksum.lower()

        except Exception as e:
            logger.error(f"Fehler bei der Checksum-Prüfung: {e}")
            return False

    def install_update(self, update_file_path: str) -> bool:
        """
        Installiert ein heruntergeladenes Update.

        Args:
            update_file_path: Pfad zur Update-Datei

        Returns:
            True bei Erfolg, False bei Fehler
        """
        if not os.path.exists(update_file_path):
            logger.error(f"Update-Datei nicht gefunden: {update_file_path}")
            return False

        self._report_progress(0, "Update wird installiert...")

        # Erstelle ein temporäres Verzeichnis für die entpackten Update-Dateien
        extract_dir = os.path.join(TEMP_UPDATE_DIR, f"extract_{datetime.now().strftime('%Y%m%d%H%M%S')}")
        os.makedirs(extract_dir, exist_ok=True)

        try:
            # Pfad zum Programmverzeichnis
            program_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))

            # Entpacke das Update
            self._report_progress(10, "Update wird entpackt...")

            import zipfile
            with zipfile.ZipFile(update_file_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)

            # Prüfe, ob ein pre-update-Skript vorhanden ist, und führe es aus
            pre_update_script = os.path.join(extract_dir, "pre_update.py")
            if os.path.exists(pre_update_script):
                self._report_progress(20, "Führe Vor-Update-Skript aus...")
                self._run_python_script(pre_update_script)

            # Erstelle ein Backup der aktuellen Installation
            backup_dir = os.path.join(TEMP_UPDATE_DIR, f"backup_{datetime.now().strftime('%Y%m%d%H%M%S')}")
            self._report_progress(30, "Erstelle Backup...")
            self._create_backup(program_dir, backup_dir)

            # Kopiere die Update-Dateien in das Programmverzeichnis
            self._report_progress(50, "Installiere Update-Dateien...")
            self._copy_update_files(extract_dir, program_dir)

            # Aktualisiere die Versionsdatei
            if self.available_version:
                with open(VERSION_FILE, 'w') as f:
                    f.write(self.available_version)

            # Prüfe, ob ein post-update-Skript vorhanden ist, und führe es aus
            post_update_script = os.path.join(extract_dir, "post_update.py")
            if os.path.exists(post_update_script):
                self._report_progress(80, "Führe Nach-Update-Skript aus...")
                self._run_python_script(post_update_script)

            # Bereinige temporäre Dateien
            self._report_progress(90, "Bereinige temporäre Dateien...")
            shutil.rmtree(extract_dir, ignore_errors=True)

            # Aktualisiere den Update-Status
            self.current_version = self.available_version
            self.update_available = False
            self.available_version = None
            self.update_info = None

            self._report_progress(100, f"Update auf Version {self.current_version} erfolgreich installiert!")
            return True

        except Exception as e:
            logger.error(f"Fehler bei der Update-Installation: {e}")
            self._report_progress(100, f"Fehler bei der Update-Installation: {e}")

            # Versuche, das Backup wiederherzustellen
            try:
                if os.path.exists(backup_dir):
                    self._report_progress(0, "Update fehlgeschlagen - stelle Backup wieder her...")
                    self._restore_backup(backup_dir, program_dir)
                    self._report_progress(100, "Backup erfolgreich wiederhergestellt")
            except Exception as restore_error:
                logger.error(f"Fehler bei der Wiederherstellung des Backups: {restore_error}")

            return False

    def _run_python_script(self, script_path: str) -> None:
        """
        Führt ein Python-Skript aus.

        Args:
            script_path: Pfad zum Python-Skript
        """
        subprocess.run([sys.executable, script_path], check=True)

    def _create_backup(self, source_dir: str, backup_dir: str) -> None:
        """
        Erstellt ein Backup des Programmverzeichnisses.

        Args:
            source_dir: Quellverzeichnis
            backup_dir: Zielverzeichnis für das Backup
        """
        # Erstelle das Backup-Verzeichnis, falls es nicht existiert
        os.makedirs(backup_dir, exist_ok=True)

        # Kopiere alle Dateien und Unterverzeichnisse
        for item in os.listdir(source_dir):
            source_item = os.path.join(source_dir, item)
            backup_item = os.path.join(backup_dir, item)

            # Ignoriere bestimmte Verzeichnisse und Dateien
            if item in ['.git', '__pycache__', 'logs', 'temp'] or item.endswith('.pyc'):
                continue

            if os.path.isdir(source_item):
                shutil.copytree(source_item, backup_item, symlinks=True)
            else:
                shutil.copy2(source_item, backup_item)

    def _restore_backup(self, backup_dir: str, target_dir: str) -> None:
        """
        Stellt ein Backup wieder her.

        Args:
            backup_dir: Backup-Verzeichnis
            target_dir: Zielverzeichnis für die Wiederherstellung
        """
        # Kopiere alle Dateien und Unterverzeichnisse zurück
        for item in os.listdir(backup_dir):
            backup_item = os.path.join(backup_dir, item)
            target_item = os.path.join(target_dir, item)

            if os.path.isdir(backup_item):
                # Wenn das Zielverzeichnis existiert, lösche es zuerst
                if os.path.exists(target_item):
                    shutil.rmtree(target_item)
                shutil.copytree(backup_item, target_item, symlinks=True)
            else:
                # Wenn die Zieldatei existiert, lösche sie zuerst
                if os.path.exists(target_item):
                    os.remove(target_item)
                shutil.copy2(backup_item, target_item)

    def _copy_update_files(self, update_dir: str, target_dir: str) -> None:
        """
        Kopiert die Update-Dateien in das Zielverzeichnis.

        Args:
            update_dir: Verzeichnis mit den Update-Dateien
            target_dir: Zielverzeichnis für die Installation
        """
        # Prüfe, ob eine update.json-Datei existiert
        update_json_path = os.path.join(update_dir, "update.json")
        if os.path.exists(update_json_path):
            # Lese die Update-Anweisungen
            with open(update_json_path, 'r') as f:
                update_instructions = json.load(f)

            # Verarbeite die Anweisungen
            if "files" in update_instructions:
                for file_info in update_instructions["files"]:
                    source_path = os.path.join(update_dir, file_info["source"])
                    target_path = os.path.join(target_dir, file_info["target"])

                    # Stelle sicher, dass das Zielverzeichnis existiert
                    os.makedirs(os.path.dirname(target_path), exist_ok=True)

                    # Kopiere die Datei
                    shutil.copy2(source_path, target_path)

            # Verarbeite zu löschende Dateien
            if "delete" in update_instructions:
                for delete_path in update_instructions["delete"]:
                    full_path = os.path.join(target_dir, delete_path)
                    if os.path.exists(full_path):
                        if os.path.isdir(full_path):
                            shutil.rmtree(full_path)
                        else:
                            os.remove(full_path)
        else:
            # Keine Anweisungen gefunden, kopiere alle Dateien
            for root, dirs, files in os.walk(update_dir):
                # Berechne den relativen Pfad
                rel_path = os.path.relpath(root, update_dir)

                # Erstelle die Zielverzeichnisse
                if rel_path != ".":
                    target_subdir = os.path.join(target_dir, rel_path)
                    os.makedirs(target_subdir, exist_ok=True)

                # Kopiere alle Dateien
                for file in files:
                    # Ignoriere bestimmte Dateien
                    if file in ["pre_update.py", "post_update.py"]:
                        continue

                    source_file = os.path.join(root, file)
                    if rel_path == ".":
                        target_file = os.path.join(target_dir, file)
                    else:
                        target_file = os.path.join(target_dir, rel_path, file)

                    shutil.copy2(source_file, target_file)


def check_and_update() -> None:
    """
    Prüft auf Updates und führt sie aus.
    """
    # Konfiguriere Logging
    logging.basicConfig(level=logging.INFO,
                      format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    try:
        print("Prüfe auf Updates...")

        # Erstelle Update-Manager
        update_manager = UpdateManager(auto_check=False)

        # Definiere Fortschritts-Callback
        def progress_callback(progress, message):
            print(f"[{progress}%] {message}")

        update_manager.set_progress_callback(progress_callback)

        # Prüfe auf Updates
        if update_manager.check_for_updates():
            print(f"Update auf Version {update_manager.available_version} verfügbar.")

            choice = input("Möchten Sie das Update herunterladen und installieren? (j/n): ")
            if choice.lower() in ['j', 'ja', 'y', 'yes']:
                # Lade das Update herunter
                update_file = update_manager.download_update()

                if update_file:
                    print(f"Update heruntergeladen: {update_file}")

                    # Installiere das Update
                    if update_manager.install_update(update_file):
                        print("Update erfolgreich installiert.")
                        print("Bitte starten Sie das Programm neu, um die Änderungen zu übernehmen.")
                    else:
                        print("Fehler bei der Installation des Updates.")
                else:
                    print("Fehler beim Herunterladen des Updates.")
            else:
                print("Update abgebrochen.")
        else:
            print("Keine Updates verfügbar.")

    except Exception as e:
        print(f"Fehler bei der Update-Prüfung: {e}")


# Beispiel für die Verwendung des UpdateManager
if __name__ == "__main__":
    check_and_update()
