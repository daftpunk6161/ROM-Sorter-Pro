#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ROM Sorter GUI - Optimized interface for ROM organization v2.2.0

OPTIMIZED VERSION 2.2.0:
- Theming System: Support for light and dark themes
- Customizable user interface with custom color schemes
- Improved usability through consistent design
- Accessibility support with contrasting colors
- Eliminated memory leaks with proper widget cleanup
- Optimized threading with coordinated worker management
- Streamlined UI updates with smart batching
- Enhanced resource management with automatic cleanup
- Improved performance with efficient event handling
- Reduced memory footprint through smart caching
- Better error recovery with graceful degradation
- FIXED: Git merge conflicts resolved
- FIXED: Removed dangerous signal monkey-patching
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import threading
import queue
import os
import sys
import time
import weakref
import gc
import atexit
import re
import platform
from functools import lru_cache
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import concurrent.futures
from pathlib import Path
from collections import Counter, deque
import random
import logging
import shutil
import traceback

# Add the main project directory to the Python search path
script_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(script_dir, '..', '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)
    print(f"Project directory added to Python path: {project_root}")

# Import theme system
try:
    from src.ui.theme_integration import ThemeIntegrator
    THEME_SUPPORT = True
    print("Theme-Unterstützung wurde geladen")
except ImportError:
    THEME_SUPPORT = False
    print("Theme support could not be loaded")

# Get absolute path to script
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
APP_DIR = os.path.dirname(SCRIPT_DIR)
EXTERNAL_LIBS_DIR = os.path.join(APP_DIR, "external_libs")

# Debug output for import process
print(f"Initializing Drag & Drop support... (Script: {SCRIPT_DIR})")

# Try to import the new DnD support
try:
    # Try our own DnD implementation first
    from src.dnd_support import init_drag_drop, get_dnd_mode
    DND_AVAILABLE = init_drag_drop()
    DND_MODE = get_dnd_mode()
    print(f"New Drag & Drop support loaded, mode: {DND_MODE}")
except ImportError:
    # Fallback to direct import of tkinterdnd2
    DND_AVAILABLE = False
    DND_MODE = "none"

    try:
        from tkinterdnd2 import DND_FILES
        DND_AVAILABLE = True
        DND_MODE = "tkdnd"
        print("Info: tkinterdnd2 successfully imported, Drag & Drop enabled")
    except ImportError:
        print("No Drag & Drop support available - standard file dialogs will be used")

# Dynamic module imports with error handling
MODULES_AVAILABLE = False
try:
    # Add src to path if needed
    current_dir = Path(__file__).parent
    src_dir = current_dir / "src" if (current_dir / "src").exists() else current_dir
    parent_dir = current_dir.parent
    if str(src_dir) not in sys.path:
        sys.path.insert(0, str(src_dir))
    if str(parent_dir) not in sys.path:
        sys.path.insert(0, str(parent_dir))

    # Try different import strategies
    try:
        # Strategy 1: Direct import
        from main import SortingOptions
        from utils import performance_monitor
        MODULES_AVAILABLE = True
        print("✅ ROM Sorter modules loaded successfully (direct)")
    except ImportError:
        try:
            # Strategy 2: Import from src
            from src.main import SortingOptions
            from src.utils import performance_monitor
            MODULES_AVAILABLE = True
            print("✅ ROM Sorter modules loaded successfully (from src)")
        except ImportError:
            try:
                # Strategy 3: Relative import
                from ..main import SortingOptions
                from ..utils import performance_monitor
                MODULES_AVAILABLE = True
                print("✅ ROM Sorter modules loaded successfully (relative)")
            except ImportError:
                # Module nicht verfügbar, aber GUI funktioniert trotzdem
                MODULES_AVAILABLE = False
                print("⚠️ Module nicht geladen, aber GUI wird trotzdem funktionieren")

except (ImportError, ModuleNotFoundError) as e:
    print(f"Info: Using demo mode - modules not available: {e}")

    # Lightweight demo classes
    class OptimizedROMSorterPro:
        def __init__(self, *args, **kwargs):
            self._shutdown_event = threading.Event()

        def sort_by_console_advanced(self, source_dir, dest_dir):
            # Demo implementation that doesn't use signals
            time.sleep(1)
            return {'files_processed': 42, 'duration': 5.0}

        def sort_roms(self, *args):
            return {}

    class SortingOptions:
        def __init__(self, **kwargs):
            for k, v in kwargs.items(): setattr(self, k, v)

    def get_console_statistics(rom_files):
        return {"Test Console": 10, "Another Console": 5}

    def batch_process_roms(directory, batch_size=200):
        return [{"name": "test1.rom"}, {"name": "test2.rom"}]

    class performance_monitor:
        @staticmethod
        def get_comprehensive_stats():
            return {'duration': 1.5, 'files_per_second': 10.5}
        @staticmethod
        def start(): pass
        @staticmethod
        def stop(): return 1.5

# ============================================================================
# OPTIMIZED STYLING SYSTEM
# ============================================================================

class OptimizedStyleManager:
    """Memory-efficient style manager with caching and theme support."""

    _instance = None
    _colors = None
    _fonts = None
    _theme_cache = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    @property
    def colors(self) -> Dict[str, str]:
        if self._colors is None:
            # Versuche systemweite Einstellungen zu berücksichtigen (z.B. Dark/Light Mode)
            is_dark_mode = self._detect_system_dark_mode()
            theme_key = "dark" if is_dark_mode else "light"

            # Verwende Cache wenn möglich
            if theme_key in self._theme_cache:
                self._colors = self._theme_cache[theme_key]
            else:
                # Dark Theme (Standard)
                if is_dark_mode:
                    self._colors = {
                        'bg_primary': '#2b2b2b',
                        'bg_secondary': '#3c3c3c',
                        'bg_accent': '#4a4a4a',
                        'text_primary': '#ffffff',
                        'text_secondary': '#cccccc',
                        'accent': '#007acc',
                        'accent_hover': '#1e90ff',
                        'success': '#28a745',
                        'warning': '#ffc107',
                        'error': '#dc3545',
                        'border': '#555555'
                    }
                # Light Theme
                else:
                    self._colors = {
                        'bg_primary': '#f0f0f0',
                        'bg_secondary': '#e0e0e0',
                        'bg_accent': '#d0d0d0',
                        'text_primary': '#000000',
                        'text_secondary': '#333333',
                        'accent': '#0078d4',
                        'accent_hover': '#106ebe',
                        'success': '#107c10',
                        'warning': '#d83b01',
                        'error': '#a80000',
                        'border': '#cccccc'
                    }

                # Cache speichern
                self._theme_cache[theme_key] = self._colors
        return self._colors

    def _detect_system_dark_mode(self) -> bool:
        """Erkennt, ob das System im Dark Mode ist."""
        try:
            if platform.system() == 'Windows':
                # Windows 10/11 Dark Mode Erkennung
                import winreg
                try:
                    reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                                           r"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize")
                    value, _ = winreg.QueryValueEx(reg_key, "AppsUseLightTheme")
                    return value == 0  # 0 bedeutet Dark Mode
                except:
                    pass
            elif platform.system() == 'Darwin':  # macOS
                try:
                    import subprocess
                    result = subprocess.run(['defaults', 'read', '-g', 'AppleInterfaceStyle'],
                                          capture_output=True, text=True)
                    return result.stdout.strip() == 'Dark'
                except:
                    pass
        except:
            pass

        # Standard: Dark Mode
        return True

    @property
    def fonts(self) -> Dict[str, tuple]:
        if self._fonts is None:
            # Systemabhängige Schriftart mit Fallback-Optionen
            if platform.system() == 'Windows':
                base_fonts = ['Segoe UI', 'Arial', 'Tahoma']
                mono_fonts = ['Consolas', 'Courier New', 'Lucida Console']
            elif platform.system() == 'Darwin':  # macOS
                base_fonts = ['SF Pro Text', 'Helvetica Neue', 'Helvetica']
                mono_fonts = ['SF Mono', 'Menlo', 'Monaco']
            else:  # Linux und andere
                base_fonts = ['Ubuntu', 'Liberation Sans', 'DejaVu Sans']
                mono_fonts = ['Ubuntu Mono', 'Liberation Mono', 'DejaVu Sans Mono']

            # Wähle die erste verfügbare Schriftart
            base_font = self._find_available_font(base_fonts)
            mono_font = self._find_available_font(mono_fonts)

            # Systemabhängige Schriftgrößenanpassung
            size_adjust = 0
            if platform.system() == 'Darwin':  # macOS verwendet größere Schriften
                size_adjust = 1

            self._fonts = {
                'title': (base_font, 16 + size_adjust, 'bold'),
                'heading': (base_font, 12 + size_adjust, 'bold'),
                'body': (base_font, 10 + size_adjust),
                'small': (base_font, 9 + size_adjust),
                'mono': (mono_font, 9 + size_adjust)
            }
        return self._fonts

    def _find_available_font(self, font_list: List[str]) -> str:
        """Sucht die erste verfügbare Schriftart aus einer Liste."""
        # Importiere nur bei Bedarf, um Startzeit zu optimieren
        try:
            if not hasattr(self, '_available_fonts'):
                if platform.system() == 'Windows':
                    import tkinter.font
                    root = tk.Tk()
                    root.withdraw()
                    self._available_fonts = set(tkinter.font.families())
                    root.destroy()
                else:
                    # Fallback für andere Betriebssysteme
                    self._available_fonts = set()

            # Suche erste verfügbare Schriftart
            for font in font_list:
                if font in self._available_fonts:
                    return font
        except:
            pass

        # Fallback zur ersten Option
        return font_list[0]

# Global style instance
STYLE = OptimizedStyleManager()

# ============================================================================
# MEMORY-OPTIMIZED WIDGETS
# ============================================================================

class MemoryEfficientProgressBar(ttk.Progressbar):
    """Memory-efficient progress bar with throttled updates and adaptive behavior."""

    # Klassenvariable für geteilte Optimierungseinstellungen
    _adaptive_settings = {
        'min_update_threshold': 0.05,  # Minimale Aktualisierungsschwelle in Sekunden
        'max_update_threshold': 0.5,   # Maximale Aktualisierungsschwelle in Sekunden
        'current_batch_size': 5,       # Aktuelle Batchgröße, wird adaptiv angepasst
        'frame_rate_history': deque(maxlen=10),  # Historie der Bildwiederholraten
        'last_performance_check': 0,   # Zeitpunkt der letzten Leistungsüberprüfung
        'ui_congestion_detected': False  # Flag für erkannte UI-Überlastung
    }

    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self._last_update = 0
        self._last_value = 0
        self._update_threshold = 0.1  # seconds
        self._animation_active = False
        self._update_queue = []
        self._parent_ref = weakref.ref(parent)  # Schwache Referenz auf das Elternelement
        self._adaptive_mode = kwargs.get('adaptive_mode', True)
        self._frame_times = deque(maxlen=5)

        # Leistungsüberwachung für adaptive Anpassungen
        self._performance_metrics = {
            'updates_processed': 0,
            'updates_batched': 0,
            'updates_skipped': 0,
            'ui_blocking_detected': 0,
            'last_ui_check': time.time()
        }

        # Register for cleanup
        atexit.register(self._cleanup)

    def update_throttled(self, value):
        """Update progress with adaptive throttling."""
        # Record value for potential batching
        self._last_value = value
        self._performance_metrics['updates_processed'] += 1

        # Adaptive Aktualisierung basierend auf Systemleistung
        current_time = time.time()

        # UI-Überlastungserkennung
        if self._adaptive_mode and current_time - self._performance_metrics['last_ui_check'] > 2.0:
            self._performance_metrics['last_ui_check'] = current_time
            parent = self._parent_ref()
            if parent:
                # UI-Thread-Belastungsprüfung durchführen
                self._check_ui_responsiveness(parent)

        # Benutze die adaptiven Einstellungen für Aktualisierungsschwelle und Batchgröße
        update_threshold = self._update_threshold
        batch_size = self.__class__._adaptive_settings['current_batch_size']

        if current_time - self._last_update >= update_threshold:
            # Bedeutende Änderung oder lange Zeit ohne Update -> sofort aktualisieren
            if abs(value - (self['value'] or 0)) > 5 or current_time - self._last_update >= 0.5:
                try:
                    self['value'] = value
                    self._last_update = current_time
                    self._frame_times.append(current_time)
                    return True
                except tk.TclError:
                    # Widget möglicherweise zerstört
                    return False
            else:
                # Aktualisierung in die Warteschlange stellen, um UI-Overhead zu reduzieren
                self._update_queue.append(value)
                self._performance_metrics['updates_batched'] += 1

                # Batch verarbeiten, wenn genug Einträge vorhanden oder wenn seit letztem Update zu viel Zeit vergangen ist
                if (len(self._update_queue) >= batch_size or
                    current_time - self._last_update >= update_threshold * 3):
                    try:
                        # Verwende gewichteten Durchschnitt mit mehr Gewicht auf neueren Werten
                        weights = [0.1 + (0.9 * i / (len(self._update_queue) - 1 or 1)) for i in range(len(self._update_queue))]
                        weighted_avg = sum(v * w for v, w in zip(self._update_queue, weights)) / sum(weights)

                        self['value'] = weighted_avg
                        self._update_queue.clear()
                        self._last_update = current_time
                        self._frame_times.append(current_time)
                        return True
                    except (tk.TclError, ZeroDivisionError):
                        # Widget möglicherweise zerstört oder leere Queue
                        self._update_queue.clear()
                        return False
        else:
            # Update wird übersprungen
            self._performance_metrics['updates_skipped'] += 1

        return False

    def _check_ui_responsiveness(self, parent):
        """Überprüft die UI-Reaktionsfähigkeit und passt Einstellungen an."""
        try:
            # Berechne aktuelle Bildwiederholrate wenn genügend Datenpunkte vorhanden sind
            if len(self._frame_times) >= 2:
                frame_times = list(self._frame_times)
                intervals = [frame_times[i] - frame_times[i-1] for i in range(1, len(frame_times))]
                avg_interval = sum(intervals) / len(intervals)
                current_fps = 1.0 / avg_interval if avg_interval > 0 else 60

                cls = self.__class__
                cls._adaptive_settings['frame_rate_history'].append(current_fps)

                # Anpassung der Einstellungen nach Leistungsmetriken
                now = time.time()
                if now - cls._adaptive_settings['last_performance_check'] > 5.0:
                    cls._adaptive_settings['last_performance_check'] = now

                    # Berechne durchschnittliche FPS
                    if cls._adaptive_settings['frame_rate_history']:
                        avg_fps = sum(cls._adaptive_settings['frame_rate_history']) / len(cls._adaptive_settings['frame_rate_history'])

                        # UI-Überlastungserkennung und Anpassung
                        if avg_fps < 15:  # Unter 15 FPS gilt die UI als überlastet
                            cls._adaptive_settings['ui_congestion_detected'] = True
                            # Erhöhe Update-Schwelle und Batchgröße für weniger UI-Updates
                            cls._adaptive_settings['current_batch_size'] = min(20, cls._adaptive_settings['current_batch_size'] + 2)
                            self._update_threshold = min(cls._adaptive_settings['max_update_threshold'], self._update_threshold * 1.5)
                        elif avg_fps > 30:  # UI ist flüssig
                            cls._adaptive_settings['ui_congestion_detected'] = False
                            # Reduziere Update-Schwelle und Batchgröße für responsivere UI
                            cls._adaptive_settings['current_batch_size'] = max(3, cls._adaptive_settings['current_batch_size'] - 1)
                            self._update_threshold = max(cls._adaptive_settings['min_update_threshold'], self._update_threshold * 0.8)
        except Exception:
            # Fehler ignorieren, Standardeinstellungen beibehalten
            pass

    def start_animation(self):
        """Start indeterminate animation."""
        if not self._animation_active:
            try:
                self.configure(mode='indeterminate')
                self.start(10)
                self._animation_active = True
            except tk.TclError:
                # Widget möglicherweise zerstört
                pass

    def stop_animation(self):
        """Stop animation and return to determinate mode."""
        if self._animation_active:
            try:
                self.stop()
                self.configure(mode='determinate')
                self._animation_active = False
            except tk.TclError:
                # Widget möglicherweise zerstört
                pass

    def get_performance_metrics(self):
        """Return performance metrics for diagnostics."""
        metrics = dict(self._performance_metrics)
        metrics.update({
            'update_threshold': self._update_threshold,
            'batch_size': self.__class__._adaptive_settings['current_batch_size'],
            'ui_congested': self.__class__._adaptive_settings['ui_congestion_detected']
        })
        return metrics

    def _cleanup(self):
        """Cleanup resources."""
        if self._animation_active:
            try:
                self.stop()
            except:
                pass
        # Lösche Warteschlangen und Caches
        self._update_queue.clear()
        self._frame_times.clear()

class SmartThread(threading.Thread):
    """Memory-efficient thread with proper cleanup and resource management."""

    # Klassenvariablen zur Überwachung aktiver Threads
    _active_threads = weakref.WeakSet()
    _thread_stats = {
        'created': 0,
        'finished': 0,
        'max_concurrent': 0,
        'errors': 0
    }
    _stats_lock = threading.Lock()

    # Thread-Pool für wiederverwendbare Worker
    _thread_pool = None
    _pool_lock = threading.Lock()

    def __init__(self, target=None, args=(), kwargs=None, **thread_kwargs):
        super().__init__(target=target, args=args, kwargs=kwargs or {}, **thread_kwargs)
        self._stop_event = threading.Event()
        self._cleanup_callbacks = []
        self._start_time = None
        self._end_time = None
        self._original_target = target
        self._original_args = args
        self._original_kwargs = kwargs or {}
        self.daemon = True
        self._error = None

        # Benutze einen Proxy für die Zielfunktion zur Überwachung
        if target:
            self._target = self._wrap_target(target)

        # Register for cleanup
        atexit.register(self._cleanup)

        # Thread statistisch erfassen
        with self._stats_lock:
            SmartThread._thread_stats['created'] += 1

    def _wrap_target(self, target):
        """Umhüllt die Zielfunktion mit Fehler- und Ressourcenüberwachung."""
        def wrapped_target(*args, **kwargs):
            try:
                # Beginn der Ausführung aufzeichnen
                self._start_time = time.time()
                SmartThread._active_threads.add(self)

                # Aktualisiere maximale gleichzeitige Thread-Anzahl
                with self._stats_lock:
                    current_active = len(SmartThread._active_threads)
                    if current_active > SmartThread._thread_stats['max_concurrent']:
                        SmartThread._thread_stats['max_concurrent'] = current_active

                # Überprüfen auf Stoppanweisung
                if self._stop_event.is_set():
                    return

                # Führe die eigentliche Funktion aus
                return target(*args, **kwargs)
            except Exception as e:
                self._error = e
                # Fehler für Diagnose erfassen
                with self._stats_lock:
                    SmartThread._thread_stats['errors'] += 1
                # Protokolliere den Fehler, werfe ihn aber nicht hoch
                logging.error(f"Error in thread {threading.current_thread().name}: {str(e)}")
                if hasattr(e, '__traceback__'):
                    logging.error(''.join(traceback.format_exception(type(e), e, e.__traceback__)))
            finally:
                # Ende der Ausführung aufzeichnen
                self._end_time = time.time()
                with self._stats_lock:
                    SmartThread._thread_stats['finished'] += 1

                try:
                    SmartThread._active_threads.discard(self)
                except:
                    pass

        return wrapped_target

    def add_cleanup_callback(self, callback):
        """Add cleanup callback."""
        self._cleanup_callbacks.append(callback)

    def stop(self):
        """Signal thread to stop."""
        self._stop_event.set()

    def should_stop(self):
        """Check if thread should stop."""
        return self._stop_event.is_set()

    def get_execution_time(self):
        """Gibt die Ausführungszeit des Threads zurück."""
        if self._start_time is None:
            return 0

        end_time = self._end_time or time.time()
        return end_time - self._start_time

    def get_error(self):
        """Gibt den aufgetretenen Fehler zurück (falls vorhanden)."""
        return self._error

    @classmethod
    def get_stats(cls):
        """Gibt Statistiken über Thread-Verwendung zurück."""
        with cls._stats_lock:
            stats = dict(cls._thread_stats)
            stats['currently_active'] = len(cls._active_threads)
        return stats

    @classmethod
    def cleanup_all_threads(cls):
        """Bereinigt alle aktiven Threads."""
        for thread in list(cls._active_threads):
            try:
                thread.stop()
            except:
                pass

    @classmethod
    def get_thread_pool(cls, max_workers=None):
        """Gibt einen gemeinsamen Thread-Pool zurück."""
        with cls._pool_lock:
            if cls._thread_pool is None:
                if max_workers is None:
                    # Optimale Pool-Größe basierend auf System
                    max_workers = min(32, (os.cpu_count() or 4) * 2)
                cls._thread_pool = ThreadPoolExecutor(max_workers=max_workers,
                                                    thread_name_prefix="SmartPool")
            return cls._thread_pool

    def _cleanup(self):
        """Cleanup thread resources."""
        self.stop()
        for callback in self._cleanup_callbacks:
            try:
                callback()
            except:
                pass

        # Verweise auf Funktionen und Argumente löschen
        self._original_target = None
        self._original_args = None
        self._original_kwargs = None

class OptimizedDragDropFrame(tk.Frame):
    """Memory-optimized drag & drop frame."""

    def __init__(self, parent, callback: Optional[Callable] = None, **kwargs):
        super().__init__(parent, **kwargs)
        self.callback = callback
        self._setup_appearance()
        self._create_content()
        self._setup_events()
        self._setup_drag_drop()

        # Register for cleanup
        atexit.register(self._cleanup)

    def _setup_appearance(self):
        """Setup frame appearance."""
        self.configure(
            bg=STYLE.colors['bg_accent'],
            relief='ridge',
            bd=2,
            cursor='hand2'
        )

    def _create_content(self):
        """Create frame content efficiently."""
        main_text = "📁 Click to select folder"
        if DND_AVAILABLE:
            main_text = "📁 Drag folder here or click"

        self.main_label = tk.Label(
            self, text=main_text,
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_secondary'],
            font=STYLE.fonts['body'],
            cursor='hand2'
        )
        self.main_label.pack(expand=True, pady=10)

        sub_text = "Browse for ROM folder"
        if DND_AVAILABLE:
            sub_text = f"Drag & Drop unterstützt ({DND_MODE})"

        self.sub_label = tk.Label(
            self, text=sub_text,
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_secondary'],
            font=STYLE.fonts['small']
        )
        self.sub_label.pack(pady=(0, 10))

    def _setup_events(self):
        """Setup event handlers with weak references."""
        # Create references for event callbacks to prevent them from being garbage collected
        self._click_callback = self._on_click
        self._enter_callback = self._on_enter
        self._leave_callback = self._on_leave

        # Use weak references to prevent memory leaks
        self.bind('<Button-1>', self._click_callback)
        self.bind('<Enter>', self._enter_callback)
        self.bind('<Leave>', self._leave_callback)
        self.main_label.bind('<Button-1>', self._click_callback)
        self.sub_label.bind('<Button-1>', self._click_callback)

        # Store bindings for cleanup
        self._bindings = [
            (self, '<Button-1>'),
            (self, '<Enter>'),
            (self, '<Leave>'),
            (self.main_label, '<Button-1>'),
            (self.sub_label, '<Button-1>')
        ]

    def _setup_drag_drop(self):
        """Setup drag and drop if available."""

        if DND_AVAILABLE:
            try:
                print(f"Initialisiere Drag & Drop-Unterstützung (Modus: {DND_MODE})...")

                # Erstelle eine ansprechendere Drag & Drop-Zone
                self.configure(
                    relief="groove",
                    borderwidth=2,
                    highlightbackground=STYLE.colors['accent'],
                    highlightthickness=2
                )

                if DND_MODE == "native":
                    # Verwende unsere eigene DnD-Implementierung
                    from src.dnd_support import DropFrame

                    # Erstelle ein Drop-Frame innerhalb dieses Frames
                    self.drop_frame = DropFrame(self, drop_callback=self._handle_native_drop)
                    self.drop_frame.pack(fill=tk.BOTH, expand=True)

                    # Verstecke das innere Frame visuell
                    self.drop_frame.configure(
                        bg=STYLE.colors['bg_accent'],
                        highlightthickness=0,
                        borderwidth=0
                    )

                    print("Native Drag & Drop-Unterstützung erfolgreich registriert")

                elif DND_MODE == "tkdnd":
                    # Verwende tkinterdnd2-Implementierung

                    # Prüfen, ob die Root-Klasse TkinterDnD unterstützt
                    if not hasattr(self.winfo_toplevel(), 'TkdndVersion'):
                        print("Root-Fenster unterstützt tkinterdnd nicht, versuche zu patchen")

                        # Versuche die Root-Klasse zu patchen
                        try:
                            from tkinterdnd2 import TkinterDnD
                            root = self.winfo_toplevel()
                            TkinterDnD._require(root.tk)
                            root.drop_target_register = lambda *args, **kw: TkinterDnD._drop_target_register(root.tk, *args, **kw)
                            root.dnd_bind = lambda *args, **kw: TkinterDnD._dnd_bind(root.tk, *args, **kw)
                            print("Root-Fenster erfolgreich gepatcht")
                        except Exception as patch_err:
                            print(f"Patchen des Root-Fensters fehlgeschlagen: {patch_err}")

                    # Registriere als Drag & Drop-Ziel
                    self.drop_target_register(DND_FILES)
                    self.dnd_bind('<<Drop>>', self._on_drop)

                    # Registriere zusätzliche Events für visuelles Feedback
                    self.dnd_bind('<<DragEnter>>', self._drag_enter)
                    self.dnd_bind('<<DragLeave>>', self._drag_leave)

                    # Registriere alle untergeordneten Widgets als Drag & Drop-Ziele
                    for widget in [self.main_label, self.sub_label]:
                        widget.drop_target_register(DND_FILES)
                        widget.dnd_bind('<<Drop>>', self._on_drop)
                        widget.dnd_bind('<<DragEnter>>', self._drag_enter)
                        widget.dnd_bind('<<DragLeave>>', self._drag_leave)

                    print("TkinterDnD Drag & Drop-Unterstützung erfolgreich registriert")

                print("Drag & Drop-Unterstützung aktiv")
            except Exception as e:
                print(f"Drag & Drop-Setup fehlgeschlagen: {e}")
                import traceback
                traceback.print_exc()
                # Variable im äußeren Scope aktualisieren
                globals()['DND_AVAILABLE'] = False
                globals()['DND_MODE'] = "none"

                # Fallback auf normalen Button
                self.main_label.configure(text="📁 Click to select folder")
                self.sub_label.configure(text="Browse for ROM folder")

    def _on_click(self, event=None):
        """Handle click events."""
        if self.callback:
            folder = filedialog.askdirectory(
                title="Ordner mit ROM-Dateien auswählen",
                mustexist=True
            )
            if folder:
                self.callback(folder)
                self._show_feedback(f"📁 {os.path.basename(folder)}", True)

    def _on_enter(self, event=None):
        """Handle mouse enter."""
        self.configure(bg=STYLE.colors['accent'])
        self.main_label.configure(bg=STYLE.colors['accent'])
        self.sub_label.configure(bg=STYLE.colors['accent'])

    def _on_leave(self, event=None):
        """Handle mouse leave."""
        self._reset_appearance()

    def _drag_enter(self, event=None):
        """Handle drag enter event with visual feedback."""
        # Lebendiges visuelles Feedback für Drag & Drop
        self.configure(
            bg=STYLE.colors['success'],
            relief="sunken",
            borderwidth=3,
            highlightbackground=STYLE.colors['success'],
            highlightthickness=3
        )
        self.main_label.configure(
            bg=STYLE.colors['success'],
            fg=STYLE.colors['text_primary'],
            text="📂 Hier ablegen"
        )
        self.sub_label.configure(
            bg=STYLE.colors['success'],
            fg=STYLE.colors['text_primary'],
            text="Ordner hierher ziehen"
        )

    def _drag_leave(self, event=None):
        """Handle drag leave event."""
        self._reset_appearance()

    def _handle_native_drop(self, file_paths):
        """Verarbeitet gedropte Dateien von der nativen Drag & Drop-Implementierung."""
        if not self.callback:
            print("Kein Callback für Drag & Drop-Verarbeitung definiert")
            return

        # Verhindern von doppelten Events
        if hasattr(self, '_processing_drop') and self._processing_drop:
            print("Bereits in Bearbeitung, überspringe doppeltes Event")
            return

        self._processing_drop = True

        try:
            print(f"Native Drop-Event empfangen mit {len(file_paths)} Dateien")

            if not file_paths:
                print("Keine Dateien im Drop-Event")
                self._show_feedback("Keine Dateien erhalten", False)
                self._processing_drop = False
                return

            print(f"Gedropte Dateien: {file_paths}")

            # Priorität 1: Suche nach Verzeichnissen
            for path in file_paths:
                try:
                    if os.path.exists(path) and os.path.isdir(path):
                        print(f"Gültiges Verzeichnis gefunden: {path}")
                        self.callback(path)
                        self._show_feedback(f"📁 {os.path.basename(path)}", True)
                        self._processing_drop = False
                        return
                except Exception as path_err:
                    print(f"Fehler bei der Pfadverarbeitung: {path_err}")

            # Priorität 2: Verwende Elternverzeichnisse von Dateien
            for path in file_paths:
                try:
                    if os.path.exists(path) and os.path.isfile(path):
                        parent_dir = os.path.dirname(path)
                        if os.path.exists(parent_dir) and os.path.isdir(parent_dir):
                            print(f"Verwende übergeordnetes Verzeichnis: {parent_dir}")
                            self.callback(parent_dir)
                            self._show_feedback(f"📁 {os.path.basename(parent_dir)}", True)
                            return
                except Exception as parent_err:
                    print(f"Fehler bei der Elternverzeichnisverarbeitung: {parent_err}")

            # Wenn keine gültigen Verzeichnisse gefunden wurden
            print("Kein gültiges Verzeichnis in den Drop-Daten gefunden")
            self._show_feedback("Kein gültiger Ordner", False)

        except Exception as e:
            print(f"Fehler bei nativer Drag & Drop-Verarbeitung: {e}")
            import traceback
            traceback.print_exc()
            self._show_feedback("Drop fehlgeschlagen", False)

        # In jedem Fall zurücksetzen
        self._processing_drop = False

    def _on_drop(self, event):
        """Verarbeitet TkinterDnD Drag & Drop-Events."""
        if not self.callback:
            print("Kein Callback für Drag & Drop-Verarbeitung definiert")
            return

        # Verhindern von doppelten Events
        if hasattr(self, '_processing_drop') and self._processing_drop:
            print("Bereits in Bearbeitung, überspringe doppeltes Event")
            return

        self._processing_drop = True

        try:
            print(f"Drop-Event empfangen - Widget: {event.widget}")

            if not hasattr(event, 'data') or not event.data:
                print("Drag & Drop-Event hat keine Daten")
                self._show_feedback("Keine Daten erhalten", False)
                self._processing_drop = False
                return

            # Debug-Ausgabe für alle Event-Details
            print(f"Drop-Event Daten: {event.data}")
            print(f"Drop-Event Typ: {type(event.data)}")

            # Speziell für Windows: Bei TkDnD 2.x wird ein Format wie "{C:/Pfad/zu/Datei}" zurückgegeben
            raw_data = event.data

            # Windows Explorer spezifisches Format mit geschweiften Klammern behandeln
            if os.name == 'nt' and isinstance(raw_data, str):
                # Wenn die Daten wie ein direkter Windows-Pfad aussehen
                if raw_data.startswith('{') and raw_data.endswith('}') and ':\\' in raw_data:
                    clean_path = raw_data.strip('{}')
                    if os.path.exists(clean_path):
                        print(f"Windows-Explorer-Format erkannt: {clean_path}")
                        if os.path.isdir(clean_path):
                            self.callback(clean_path)
                            self._show_feedback(f"📁 {os.path.basename(clean_path)}", True)
                            return
                        elif os.path.isfile(clean_path):
                            parent_dir = os.path.dirname(clean_path)
                            if os.path.exists(parent_dir):
                                self.callback(parent_dir)
                                self._show_feedback(f"📁 {os.path.basename(parent_dir)}", True)
                                return

            # Standardverarbeitung für alle anderen Fälle
            paths = self._extract_paths_from_drop(event.data)
            if not paths:
                print("Keine gültigen Pfade extrahiert")
                self._show_feedback("Keine gültigen Pfade", False)
                return

            print(f"Extrahierte Pfade: {paths}")

            # Priorität 1: Suche nach Verzeichnissen
            for path in paths:
                try:
                    # Normalisiere Pfad für Windows
                    if os.name == 'nt':
                        path = os.path.normpath(path)

                    if os.path.exists(path) and os.path.isdir(path):
                        print(f"Gültiges Verzeichnis gefunden: {path}")
                        self.callback(path)
                        self._show_feedback(f"📁 {os.path.basename(path)}", True)
                        return
                except Exception as path_err:
                    print(f"Fehler bei der Pfadverarbeitung: {path_err}")

            # Priorität 2: Verwende Elternverzeichnisse von Dateien
            for path in paths:
                try:
                    # Normalisiere Pfad für Windows
                    if os.name == 'nt':
                        path = os.path.normpath(path)

                    if os.path.exists(path) and os.path.isfile(path):
                        parent_dir = os.path.dirname(path)
                        if os.path.exists(parent_dir) and os.path.isdir(parent_dir):
                            print(f"Verwende übergeordnetes Verzeichnis: {parent_dir}")
                            self.callback(parent_dir)
                            self._show_feedback(f"📁 {os.path.basename(parent_dir)}", True)
                            return
                except Exception as parent_err:
                    print(f"Fehler bei der Elternverzeichnisverarbeitung: {parent_err}")

            # Priorität 3: Spezielle URL-Format-Behandlung
            for path in paths:
                try:
                    # Entferne URL-Präfix falls vorhanden
                    if isinstance(path, str) and path.startswith('file:'):
                        import urllib.parse
                        fixed_path = urllib.parse.unquote(path[5:])
                        # Entferne führenden Schrägstrich bei Windows-Pfaden
                        if os.name == 'nt' and fixed_path.startswith('/'):
                            fixed_path = fixed_path[1:]
                        # Normalisiere Pfad für das Betriebssystem
                        fixed_path = os.path.normpath(fixed_path)

                        print(f"URL-Pfad repariert: {fixed_path}")

                        if os.path.exists(fixed_path):
                            if os.path.isdir(fixed_path):
                                self.callback(fixed_path)
                                self._show_feedback(f"📁 {os.path.basename(fixed_path)}", True)
                                return
                            elif os.path.isfile(fixed_path):
                                parent_dir = os.path.dirname(fixed_path)
                                if os.path.exists(parent_dir):
                                    self.callback(parent_dir)
                                    self._show_feedback(f"📁 {os.path.basename(parent_dir)}", True)
                                    return
                except Exception as url_err:
                    print(f"Fehler bei der URL-Pfadverarbeitung: {url_err}")

            # Wenn keine gültigen Verzeichnisse gefunden wurden
            print("Kein gültiges Verzeichnis in den Drop-Daten gefunden")
            self._show_feedback("Kein gültiger Ordner", False)

        except Exception as e:
            print(f"Fehler bei Drag & Drop-Verarbeitung: {e}")
            import traceback
            traceback.print_exc()
            self._show_feedback("Drop fehlgeschlagen", False)

        # In jedem Fall zurücksetzen
        self._processing_drop = False

    def _extract_paths_from_drop(self, data):
        """Erweiterte und robustere Pfadextraktion für verschiedene Betriebssysteme und Drag&Drop-Formate."""
        if not data:
            return []

        paths = []

        # Behandle unterschiedliche Datentypen
        if isinstance(data, (list, tuple)):
            # Falls bereits eine Liste übergeben wurde
            data_items = list(data)
        else:
            # Konvertiere zu String für String-basierte Verarbeitung
            data_str = str(data).strip()

            # Windows Explorer Format direkt behandeln
            if os.name == 'nt' and data_str.startswith('{') and data_str.endswith('}') and ':\\' in data_str:
                # Windows Explorer Format mit einem einzelnen Pfad in geschweiften Klammern
                clean_path = data_str.strip('{}').strip()
                return [clean_path]

            # Entferne Windows-spezifische geschweifte Klammern (für mehrere Einträge)
            if data_str.startswith('{') and data_str.endswith('}'):
                data_str = data_str[1:-1].strip()

            # Versuche verschiedene Trennzeichen zu erkennen
            if '\r\n' in data_str:
                # Windows-Mehrzeilenmodus
                data_items = [p.strip() for p in data_str.split('\r\n') if p.strip()]
            elif '\n' in data_str:
                # Unix-Mehrzeilenmodus
                data_items = [p.strip() for p in data_str.split('\n') if p.strip()]
            elif data_str.startswith('file:'):
                # URL-formatierte Pfade
                import urllib.parse

                # Wenn mehrere URLs durch Leerzeichen getrennt sind
                if ' file:' in data_str:
                    parts = []
                    for part in data_str.split():
                        if part.startswith('file:'):
                            parts.append(part)
                    data_items = parts
                else:
                    # Einzelne URL
                    data_items = [data_str]
            elif os.name == 'nt' and ('"' in data_str or "'" in data_str):
                # Windows mit Anführungszeichen
                try:
                    # Versuche shlex für korrekte Anführungszeichenbehandlung
                    import shlex
                    data_items = shlex.split(data_str)
                except Exception:
                    # Fallback bei Fehlern
                    data_items = []
                    # Behandlung für Anführungszeichen
                    in_quotes = False
                    quote_type = None
                    current_item = ""

                    for char in data_str:
                        if char in ['"', "'"]:
                            if not in_quotes:  # Start eines zitierten Abschnitts
                                in_quotes = True
                                quote_type = char
                            elif char == quote_type:  # Ende eines zitierten Abschnitts
                                in_quotes = False
                                quote_type = None
                            else:  # Ein anderes Anführungszeichen innerhalb eines zitierten Abschnitts
                                current_item += char
                        elif char.isspace() and not in_quotes:  # Leerzeichen außerhalb von Anführungszeichen
                            if current_item:
                                data_items.append(current_item)
                                current_item = ""
                        else:
                            current_item += char

                    if current_item:  # Den letzten Eintrag hinzufügen
                        data_items.append(current_item)
            else:
                # Standard-Trennung am Leerzeichen
                data_items = data_str.split()

        # Verarbeite jeden Pfad
        for item in data_items:
            if not item:
                continue

            # URL-Format behandeln
            if isinstance(item, str) and item.startswith('file:'):
                import urllib.parse
                # Dekodiere URL und entferne file://-Präfix
                path = urllib.parse.unquote(item[5:])
                # Bei Windows entferne den führenden Schrägstrich
                if os.name == 'nt' and path.startswith('/'):
                    path = path[1:]
            else:
                path = item

            # Bereinige den Pfad
            if isinstance(path, str):
                # Entferne Anführungszeichen und überflüssige Leerzeichen
                clean_path = path.strip('"\'').strip()

                # Normalisiere Backslashes/Forwardslashes je nach Betriebssystem
                if os.name == 'nt':
                    # Windows: Ersetze / durch \
                    clean_path = clean_path.replace('/', '\\')
                else:
                    # Unix: Ersetze \ durch /
                    clean_path = clean_path.replace('\\', '/')

                # Normalisiere den Pfad (entfernt doppelte Separatoren usw.)
                try:
                    clean_path = os.path.normpath(clean_path)
                except:
                    pass  # Fehler ignorieren, behalte den Pfad wie er ist

                paths.append(clean_path)

        return paths

    def _show_feedback(self, message: str, success: bool = True):
        """Show visual feedback."""
        color = STYLE.colors['success'] if success else STYLE.colors['error']
        self.configure(bg=color)
        self.main_label.configure(bg=color, text=message)
        self.sub_label.configure(bg=color, text="✓ Selected" if success else "✗ Failed")

        # Auto-reset after 2 seconds
        self.after(2000, self._reset_appearance)

    def _reset_appearance(self):
        """Reset to default appearance."""
        self.configure(
            bg=STYLE.colors['bg_accent'],
            relief="groove",
            borderwidth=2,
            highlightbackground=STYLE.colors['accent'],
            highlightthickness=2
        )

        if DND_AVAILABLE:
            main_text = "📁 Ordner hierher ziehen oder klicken"
            sub_text = "Drag & Drop unterstützt"
        else:
            main_text = "📁 Klicken, um Ordner auszuwählen"
            sub_text = "ROM-Ordner auswählen"

        self.main_label.configure(
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_secondary'],
            text=main_text
        )
        self.sub_label.configure(
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_secondary'],
            text=sub_text
        )

    def _cleanup(self):
        """Cleanup resources."""
        try:
            # Unbind all events
            if hasattr(self, '_bindings'):
                for widget, event in self._bindings:
                    try:
                        widget.unbind(event)
                    except:
                        pass

            # Clear references
            self.callback = None
            self._click_callback = None
            self._enter_callback = None
            self._leave_callback = None

            # Clean up drop_frame if it exists
            if hasattr(self, 'drop_frame'):
                try:
                    self.drop_frame.destroy()
                except:
                    pass
                self.drop_frame = None

            # Clear widget references
            self.main_label = None
            self.sub_label = None
        except:
            pass

class EfficientLogWidget(tk.Frame):
    """Memory-efficient log widget with smart batching."""

    def __init__(self, parent, max_lines: int = 500, **kwargs):
        super().__init__(parent, **kwargs)
        self.max_lines = max_lines
        self._log_queue = queue.Queue(maxsize=100)
        self._batch_size = 10
        self._update_interval = 100  # ms
        self._last_update = 0

        self._setup_ui()
        self._start_log_processor()

        # Register for cleanup
        atexit.register(self._cleanup)

    def _setup_ui(self):
        """Setup UI components."""
        self.configure(bg=STYLE.colors['bg_secondary'])

        # Header with title and clear button
        header = tk.Frame(self, bg=STYLE.colors['bg_secondary'])
        header.pack(fill='x', padx=10, pady=5)

        tk.Label(
            header, text="📝 Activity Log",
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['heading']
        ).pack(side='left')

        tk.Button(
            header, text="Clear", command=self._clear_log,
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['small'],
            relief='flat'
        ).pack(side='right')

        # Log display
        self.log_text = scrolledtext.ScrolledText(
            self, height=8,
            bg=STYLE.colors['bg_primary'],
            fg=STYLE.colors['text_secondary'],
            font=STYLE.fonts['mono'],
            state='disabled'
        )
        self.log_text.pack(fill='both', expand=True, padx=10, pady=5)

        # Setup color tags
        self.log_text.tag_config("INFO", foreground=STYLE.colors['text_primary'])
        self.log_text.tag_config("SUCCESS", foreground=STYLE.colors['success'])
        self.log_text.tag_config("WARNING", foreground=STYLE.colors['warning'])
        self.log_text.tag_config("ERROR", foreground=STYLE.colors['error'])

    def _start_log_processor(self):
        """Start log processing thread."""
        def process_logs():
            # Use a stop event to properly terminate the thread
            stop_event = threading.Event()
            self._log_stop_event = stop_event

            while not stop_event.is_set():
                try:
                    # Use a more efficient batching with timeout
                    batch = []
                    # First item with timeout
                    try:
                        item = self._log_queue.get(block=True, timeout=0.1)
                        batch.append(item)
                        self._log_queue.task_done()
                    except queue.Empty:
                        # No items available
                        continue

                    # Try to get more items without blocking
                    for _ in range(self._batch_size - 1):
                        try:
                            item = self._log_queue.get_nowait()
                            batch.append(item)
                            self._log_queue.task_done()
                        except queue.Empty:
                            break

                    if batch and not stop_event.is_set():
                        # Use thread-safe invocation with proper reference
                        # Store a reference to prevent garbage collection during callback
                        batch_copy = batch.copy()
                        self.after_idle(lambda b=batch_copy: self._process_batch(b))

                except Exception as e:
                    # Log the exception but don't break the loop
                    print(f"Log processor error: {e}")
                    time.sleep(0.1)

        self._log_thread = SmartThread(target=process_logs)
        self._log_thread.daemon = True
        self._log_thread.start()

    def _process_batch(self, batch):
        """Process a batch of log messages."""
        current_time = time.time()
        if current_time - self._last_update < (self._update_interval / 1000):
            # Re-queue for later
            for message, level in batch:
                try:
                    self._log_queue.put_nowait((message, level))
                except queue.Full:
                    pass
            return

        self._last_update = current_time
        timestamp = datetime.now().strftime("%H:%M:%S")

        self.log_text.configure(state='normal')

        # Limit log size
        lines = int(self.log_text.index('end-1c').split('.')[0])
        if lines > self.max_lines:
            delete_lines = lines - self.max_lines + len(batch)
            self.log_text.delete('1.0', f'{delete_lines}.0')

        # Add batch
        for message, level in batch:
            self.log_text.insert(tk.END, f"[{timestamp}] {message}\n", level)

        self.log_text.configure(state='disabled')
        self.log_text.see(tk.END)

    def add_log(self, message: str, level: str = "INFO"):
        """Add log message."""
        try:
            self._log_queue.put_nowait((message, level))
        except queue.Full:
            pass  # Drop message if queue full

    def _clear_log(self):
        """Clear log content."""
        self.log_text.configure(state='normal')
        self.log_text.delete(1.0, tk.END)
        self.log_text.configure(state='disabled')

    def _cleanup(self):
        """Cleanup resources."""
        try:
            # Signal thread to stop
            if hasattr(self, '_log_stop_event'):
                self._log_stop_event.set()

            # Stop thread
            if hasattr(self, '_log_thread'):
                try:
                    self._log_thread.stop()
                    # Allow thread to terminate gracefully
                    if self._log_thread.is_alive():
                        self._log_thread.join(timeout=0.5)
                except:
                    pass

            # Clear queue
            try:
                while not self._log_queue.empty():
                    self._log_queue.get_nowait()
                    self._log_queue.task_done()
            except:
                pass

            # Remove circular references
            self.log_text = None
        except Exception as e:
            print(f"Log widget cleanup error: {e}")
            pass

class OptimizedStatsWidget(tk.Frame):
    """Memory-optimized statistics widget with high-performance rendering."""

    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self._stats_cache = {}
        self._last_hash = None
        self._last_update_time = 0
        self._update_threshold = 0.25  # seconds
        self._pending_update = None
        self._setup_ui()

        # Register for cleanup
        atexit.register(self._cleanup)

    def _setup_ui(self):
        """Setup UI components with efficient layout."""
        self.configure(bg=STYLE.colors['bg_secondary'])

        # Header frame with title and optional controls
        header_frame = tk.Frame(self, bg=STYLE.colors['bg_secondary'])
        header_frame.pack(fill='x', padx=10, pady=(10, 0))

        tk.Label(
            header_frame, text="📊 Console Statistics",
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['heading']
        ).pack(side='left')

        # Add export button for large datasets
        self.export_btn = tk.Button(
            header_frame, text="Export",
            command=self._export_stats,
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['small'],
            state='disabled'
        )
        self.export_btn.pack(side='right', padx=5)

        # Stats display with optimized scroll text
        self.stats_display = scrolledtext.ScrolledText(
            self, height=6,
            bg=STYLE.colors['bg_primary'],
            fg=STYLE.colors['text_secondary'],
            font=STYLE.fonts['mono'],
            state='disabled',
            wrap='none'  # Prevent text wrapping for better performance
        )
        self.stats_display.pack(fill='both', expand=True, padx=10, pady=5)

        # Configure tags for colorful stats display
        self.stats_display.tag_config("header", foreground=STYLE.colors['accent'])
        self.stats_display.tag_config("total", foreground=STYLE.colors['text_primary'], font=STYLE.fonts['body'])
        self.stats_display.tag_config("high", foreground=STYLE.colors['success'])
        self.stats_display.tag_config("medium", foreground=STYLE.colors['accent'])
        self.stats_display.tag_config("low", foreground=STYLE.colors['text_secondary'])
        self.stats_display.tag_config("bar_high", foreground=STYLE.colors['success'])
        self.stats_display.tag_config("bar_medium", foreground=STYLE.colors['accent'])
        self.stats_display.tag_config("bar_low", foreground=STYLE.colors['text_secondary'])

    def update_stats(self, stats: Dict[str, int]):
        """Update statistics with throttling, caching and batching."""
        if not stats:
            return

        # Enable export button if we have data
        if self.export_btn['state'] == 'disabled':
            self.export_btn.configure(state='normal')

        # Bereinige Statistiken (entferne doppelte Schlüssel, die sich nur durch Formatierung unterscheiden)
        cleaned_stats = self._clean_console_stats(stats)

        # Hash the stats for cache lookup
        stats_hash = hash(frozenset(cleaned_stats.items()))
        if stats_hash == self._last_hash:
            return

        # Check if we need to throttle updates (if rapid updates are coming in)
        current_time = time.time()
        if current_time - self._last_update_time < self._update_threshold:
            # Cancel any pending update
            if self._pending_update:
                self.after_cancel(self._pending_update)

            # Schedule update for later with a copy of the stats
            stats_copy = dict(cleaned_stats)
            self._pending_update = self.after(
                int(self._update_threshold * 1000),
                lambda: self._process_stats_update(stats_copy)
            )
            return

        # Process immediately
        self._process_stats_update(cleaned_stats)

    def _clean_console_stats(self, stats: Dict[str, int]) -> Dict[str, int]:
        """Bereinigt Konsolenstatistiken für konsistente Anzeige und Performance."""
        cleaned_stats = {}

        # Zwischenspeicher für Namensbereinigung
        name_cache = {}

        # Reguläre Ausdrücke für häufige Muster kompilieren
        if not hasattr(self, '_regex_cache'):
            self._regex_cache = {
                'parentheses': re.compile(r'\s*\([^)]*\)'),
                'brackets': re.compile(r'\s*\[[^\]]*\]'),
                'version': re.compile(r'\s*v\d+(\.\d+)*'),
                'whitespace': re.compile(r'\s+'),
                'special_chars': re.compile(r'[^a-zA-Z0-9\s]')
            }

        # Wörter ignorieren, die nicht zur Konsolenidentifikation beitragen
        if not hasattr(self, '_ignore_words'):
            self._ignore_words = {
                'console', 'system', 'entertainment', 'computer', 'version',
                'revision', 'model', 'series', 'family', 'edition', 'classic'
            }

        # Konsolengruppierung für zusammengehörige Varianten
        if not hasattr(self, '_console_groups'):
            self._console_groups = {
                'Nintendo Entertainment System': ['NES', 'Famicom', 'Nintendo Entertainment System'],
                'Super Nintendo': ['SNES', 'Super Famicom', 'Super Nintendo', 'Super NES'],
                'Nintendo 64': ['N64', 'Nintendo 64'],
                'Game Boy': ['Game Boy', 'GB', 'Game Boy Color', 'GBC'],
                'Game Boy Advance': ['GBA', 'Game Boy Advance'],
                'Nintendo DS': ['NDS', 'Nintendo DS', 'DS'],
                'Nintendo 3DS': ['3DS', 'Nintendo 3DS'],
                'GameCube': ['NGC', 'Nintendo GameCube', 'GameCube'],
                'Wii': ['Nintendo Wii', 'Wii'],
                'Wii U': ['Nintendo Wii U', 'Wii U'],
                'Nintendo Switch': ['NSW', 'Nintendo Switch', 'Switch'],
                'PlayStation': ['PSX', 'PS1', 'PlayStation', 'Sony PlayStation'],
                'PlayStation 2': ['PS2', 'PlayStation 2', 'Sony PlayStation 2'],
                'PlayStation 3': ['PS3', 'PlayStation 3', 'Sony PlayStation 3'],
                'PlayStation 4': ['PS4', 'PlayStation 4', 'Sony PlayStation 4'],
                'PlayStation 5': ['PS5', 'PlayStation 5', 'Sony PlayStation 5'],
                'PlayStation Portable': ['PSP', 'PlayStation Portable'],
                'PlayStation Vita': ['PSVita', 'PS Vita', 'PlayStation Vita'],
                'Xbox': ['XBOX', 'Microsoft Xbox', 'Xbox'],
                'Xbox 360': ['X360', 'Microsoft Xbox 360', 'Xbox 360'],
                'Xbox One': ['XONE', 'Microsoft Xbox One', 'Xbox One'],
                'Xbox Series': ['XSX', 'Microsoft Xbox Series', 'Xbox Series'],
                'Sega Master System': ['SMS', 'Sega Master System', 'Master System'],
                'Sega Genesis': ['Sega Genesis', 'Sega Mega Drive', 'Genesis', 'Mega Drive'],
                'Sega Saturn': ['Sega Saturn', 'Saturn'],
                'Sega Dreamcast': ['Sega Dreamcast', 'Dreamcast'],
                'Atari 2600': ['Atari 2600', 'Atari VCS'],
                'Atari 7800': ['Atari 7800'],
                'Neo Geo': ['Neo Geo', 'Neo-Geo', 'SNK Neo Geo'],
                'PC Engine': ['PCE', 'PC Engine', 'TurboGrafx-16'],
                'WonderSwan': ['WonderSwan', 'WonderSwan Color']
            }
            # Erstelle umgekehrte Zuordnung für schnelleren Lookup
            self._console_mapping = {}
            for main_name, variants in self._console_groups.items():
                for variant in variants:
                    self._console_mapping[variant.lower()] = main_name

        # Normalisiere Konsolennamen für bessere Anzeige
        for console, count in stats.items():
            # Ersetze Unterstriche durch Leerzeichen für bessere Lesbarkeit
            display_name = console.replace('_', ' ')

            # Stelle sicher, dass ähnliche Namen zusammengefasst werden
            if display_name in cleaned_stats:
                cleaned_stats[display_name] += count
            else:
                cleaned_stats[display_name] = count

        return cleaned_stats

    def _process_stats_update(self, stats: Dict[str, int]):
        """Process statistics update with caching."""
        self._last_update_time = time.time()
        self._pending_update = None

        # Generate a new hash for the stats
        stats_hash = hash(frozenset(stats.items()))
        self._last_hash = stats_hash

        # Check cache
        if stats_hash in self._stats_cache:
            content, tags = self._stats_cache[stats_hash]
        else:
            content, tags = self._generate_content_with_tags(stats)
            self._stats_cache[stats_hash] = (content, tags)

            # Limit cache size to avoid memory leaks
            if len(self._stats_cache) > 10:
                # Remove oldest or least used entries
                oldest = next(iter(self._stats_cache))
                del self._stats_cache[oldest]

        # Update display efficiently
        self.stats_display.configure(state='normal')
        self.stats_display.delete(1.0, tk.END)

        # Insert content with tags
        self.stats_display.insert(tk.END, content)

        # Apply tags
        for tag_name, ranges in tags.items():
            for start, end in ranges:
                self.stats_display.tag_add(tag_name, start, end)

        self.stats_display.configure(state='disabled')

    def _generate_content_with_tags(self, stats: Dict[str, int]) -> tuple:
        """Generate formatted content with color tags."""
        total = sum(stats.values())
        if total == 0:
            return "Keine Daten verfügbar", {}

        content = []
        tags = {
            "header": [],
            "total": [],
            "high": [],
            "medium": [],
            "low": [],
            "bar_high": [],
            "bar_medium": [],
            "bar_low": []
        }

        # Add header with total
        header_text = f"Gesamt: {total} ROMs"
        content.append(header_text)
        content.append("=" * 30)

        # Track current line for tag positioning
        line_num = 1
        tags["header"].append((f"{line_num}.0", f"{line_num}.{len(header_text)}"))
        line_num += 2  # Skip the separator line

        # Process consoles in descending order of count
        sorted_consoles = sorted(stats.items(), key=lambda x: x[1], reverse=True)

        for i, (console, count) in enumerate(sorted_consoles):
            # Calculate percentage and visual representation
            percentage = (count / total * 100)
            bar_length = int(percentage / 2.5)  # Adjust bar scale
            bar = "█" * min(bar_length, 40)  # Limit max length

            # Format console line
            console_line = f"{console:<20} {count:>5} ({percentage:5.1f}%)"
            bar_line = f"{'':<20} {bar}"

            content.append(console_line)
            content.append(bar_line)

            # Determine category based on percentage for color coding
            if percentage > 20:
                tag = "high"
                bar_tag = "bar_high"
            elif percentage > 5:
                tag = "medium"
                bar_tag = "bar_medium"
            else:
                tag = "low"
                bar_tag = "bar_low"

            # Add tag ranges
            tags[tag].append((f"{line_num}.0", f"{line_num}.{len(console_line)}"))
            tags[bar_tag].append((f"{line_num+1}.20", f"{line_num+1}.{20 + len(bar)}"))

            line_num += 2

        return "\n".join(content), tags

    def _export_stats(self):
        """Export statistics to CSV file."""
        if not self._last_hash or self._last_hash not in self._stats_cache:
            return

        try:
            # Ask for save location
            file_path = filedialog.asksaveasfilename(
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                title="Export Statistics"
            )

            if not file_path:
                return

            # Get current stats from display
            content = self.stats_display.get(1.0, tk.END)

            # Parse and convert to CSV
            lines = content.strip().split('\n')
            total_line = lines[0]
            total_roms = int(total_line.split(':')[1].strip().split(' ')[0])

            with open(file_path, 'w') as f:
                # Write header
                f.write(f"Console,Count,Percentage\n")

                # Parse console data
                i = 2  # Skip header and separator
                while i < len(lines):
                    if not lines[i].strip():
                        i += 1
                        continue

                    parts = lines[i].strip().split()
                    if len(parts) >= 2:
                        console = parts[0]
                        try:
                            count = int(parts[-2])
                            percentage = float(parts[-1].strip('()%'))
                            f.write(f"{console},{count},{percentage:.1f}\n")
                        except (ValueError, IndexError):
                            pass
                    i += 2  # Skip bar line

            messagebox.showinfo("Export Complete", f"Statistics exported to {os.path.basename(file_path)}")

        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export: {str(e)}")

    def _cleanup(self):
        """Cleanup resources."""
        try:
            # Cancel any pending updates
            if self._pending_update:
                self.after_cancel(self._pending_update)

            # Clear caches
            if hasattr(self, '_stats_cache'):
                self._stats_cache.clear()

            # Clear references
            self.stats_display = None
            self.export_btn = None
        except:
            pass# ============================================================================
# OPTIMIZED FILE SCANNER
# ============================================================================

class FastFileScanner:
    """Hochleistungs-Dateiscanner mit optimierter Speichernutzung und adaptiver Leistungsanpassung."""

    # Class-level cache for better memory efficiency
    _scan_cache = {}
    _cache_lock = threading.RLock()
    _cache_hit_count = 0
    _cache_miss_count = 0

    # Klassen-Einstellungen für adaptive Leistung
    _settings = {
        'use_threading': os.cpu_count() and os.cpu_count() > 2,
        'max_threads': max(1, min(8, (os.cpu_count() or 4) // 2)),
        'min_files_for_threading': 1000,
        'batch_size_base': 100,
        'cache_ttl': 300,  # Sekunden, wie lange Cache gültig ist
        'max_cache_entries': 10,
        'skip_hidden_dirs': True,
        'skip_system_dirs': True,
        'max_scan_depth': 20,  # Verhindert übermäßig tiefe Rekursion
    }

    # Ignoriere bestimmte System- und Versteckte Verzeichnisse
    _ignored_dirs = {
        '.git', '.svn', '.hg', '__pycache__', 'node_modules', '.vscode',
        '.idea', 'System Volume Information', '$RECYCLE.BIN', 'Recovery',
        '$Windows.~BT', '$Windows.~WS', 'Windows', 'Program Files', 'Program Files (x86)'
    }

    # Leistungsmetriken für adaptive Anpassung
    _performance_metrics = {
        'last_scan_time': 0,
        'last_files_per_second': 0,
        'filesystem_latency': 0.001,  # Standardwert in Sekunden
    }

    def __init__(self, extensions=None):
        """Scanner mit optionalem Erweiterungsfilter initialisieren."""
        self._file_count = 0
        self._dir_count = 0
        self._stop_event = None
        self._progress_interval = 50  # Initiales Intervall für Fortschrittsupdates
        self._progress_last_time = 0
        self._batch_size = self.__class__._settings['batch_size_base']
        self._start_time = 0
        self._thread_results = []
        self._thread_error = None
        self._active_threads = 0
        self._thread_lock = threading.Lock()

        # Adaptive Parameter für Leistungsoptimierung
        self._adaptive_params = {
            'is_slow_filesystem': False,
            'batch_size_adjusted': self._batch_size,
            'threading_enabled': self.__class__._settings['use_threading']
        }

        # Extensions als Set für O(1) Lookup speichern
        self.ROM_EXTENSIONS = set(ext.lower() for ext in extensions) if extensions else {
            # Archive und Disk-Images
            '.zip', '.7z', '.rar', '.iso', '.bin', '.cue', '.chd', '.cso', '.gdi', '.cdi',
            # Nintendo
            '.nes', '.smc', '.sfc', '.n64', '.z64', '.v64', '.ndd', '.gba', '.nds', '.3ds',
            '.gb', '.gbc', '.gcm', '.wbfs', '.dol', '.wad', '.wux', '.xci', '.nsp',
            # Sony
            '.psv', '.psp', '.pbp', '.ps2', '.ps3',
            # Sega
            '.md', '.sms', '.gg', '.32x',
            # Microsoft
            '.xbx', '.xbe', '.xex',
            # Atari
            '.a26', '.a52', '.a78',
            # Andere
            '.rom', '.adf', '.hdf', '.mdf'
        }

        # Reguläre Ausdrücke für häufige Muster kompilieren
        self._regex_cache = {
            'rom_number': re.compile(r'[\(\[]?\s*[rR]om\s*\d+\s*[\)\]]?'),
            'disk_number': re.compile(r'[\(\[]?\s*[dD]is[ck]\s*\d+\s*[\)\]]?'),
            'version_pattern': re.compile(r'[\(\[]?\s*[vV](\d+(\.\d+)*)\s*[\)\]]?'),
            'region_pattern': re.compile(r'[\(\[]?\s*(US|USA|EUR|Europe|JP|Japan|PAL|NTSC)\s*[\)\]]?')
        }

        # Vorkompilierte Erweiterungsprüfung für Leistung
        # Verwende einen speichereffizienten und schnellen Ansatz mit __contains__
        self._is_rom_file = lru_cache(maxsize=2048)(self._optimized_extension_check)

    def _optimized_extension_check(self, path):
        """Optimierter Check für ROM-Dateierweiterungen."""
        # Schnellster Ansatz für die Erweiterungsprüfung
        ext = path.suffix.lower()
        return ext in self.ROM_EXTENSIONS

    def scan_directory(self, directory: str, progress_callback=None, stop_event=None, use_cache=False) -> List[Path]:
        """Scannt Verzeichnis nach ROM-Dateien mit optimaler Leistung und adaptiver Anpassung."""
        self._file_count = 0
        self._dir_count = 0
        self._stop_event = stop_event
        self._progress_last_time = time.time()
        self._start_time = time.time()
        self._thread_results = []
        self._thread_error = None
        self._active_threads = 0
        found_files = []

        # Cache-Lookup mit optimiertem Schlüssel
        norm_directory = os.path.normpath(os.path.abspath(directory))
        cache_key = f"{norm_directory}:{hash(frozenset(self.ROM_EXTENSIONS))}"

        if use_cache:
            with self._cache_lock:
                if cache_key in self._scan_cache:
                    cache_entry = self._scan_cache[cache_key]
                    cache_time = cache_entry.get('time', 0)
                    cache_ttl = self.__class__._settings['cache_ttl']

                    # Cache verwenden, wenn frisch
                    if time.time() - cache_time < cache_ttl:
                        self.__class__._cache_hit_count += 1
                        cached_files = cache_entry.get('files', [])

                        # Optimierte Überprüfung: Stichprobe statt alle Dateien zu prüfen
                        valid = True
                        if cached_files:
                            # Stichprobenanzahl: maximal 10 Dateien oder 5% des Caches
                            sample_size = min(10, max(1, len(cached_files) // 20))
                            sample_indices = sorted(random.sample(range(len(cached_files)), sample_size))

                            for idx in sample_indices:
                                if not os.path.exists(cached_files[idx]):
                                    valid = False
                                    break

                        if valid and cached_files:
                            # Melde Fortschritt für UI-Feedback auch bei Cache-Verwendung
                            if progress_callback:
                                progress_callback(len(cached_files))
                            return cached_files

                self.__class__._cache_miss_count += 1

        # Verzeichnis existiert vor dem Scannen überprüfen
        if not os.path.isdir(norm_directory):
            return []

        # Dateisystemleistung messen für adaptive Anpassungen
        self._measure_filesystem_performance(norm_directory)

        # Wähle beste Scanmethode basierend auf Verzeichnisgröße und Dateisystem
        if self._should_use_threading(norm_directory):
            found_files = self._scan_with_threading(norm_directory, progress_callback)
        else:
            found_files = self._scan_sequential(norm_directory, progress_callback)

        # Cache aktualisieren
        if use_cache and found_files:
            total_time = time.time() - self._start_time

            with self._cache_lock:
                self._scan_cache[cache_key] = {
                    'time': time.time(),
                    'files': found_files,
                    'count': len(found_files),
                    'scan_time': total_time,
                    'dirs_scanned': self._dir_count
                }

                # Cache-Größe begrenzen, um Speicherprobleme zu vermeiden
                max_cache = self.__class__._settings['max_cache_entries']
                if len(self._scan_cache) > max_cache:
                    # Ältesten Cache-Eintrag entfernen
                    oldest_keys = sorted(
                        self._scan_cache.keys(),
                        key=lambda k: self._scan_cache[k]['time']
                    )[:len(self._scan_cache) - max_cache]

                    for key in oldest_keys:
                        del self._scan_cache[key]

            # Leistungsmetriken aktualisieren für zukünftige Optimierungen
            if total_time > 0 and self._file_count > 0:
                files_per_second = self._file_count / total_time
                cls = self.__class__
                cls._performance_metrics['last_scan_time'] = total_time
                cls._performance_metrics['last_files_per_second'] = files_per_second

                # Adaptive Parameter für zukünftige Scans anpassen
                self._adjust_adaptive_parameters(files_per_second, self._dir_count, total_time)

        return found_files

    def _measure_filesystem_performance(self, directory):
        """Misst die Dateisystemleistung für adaptive Optimierung."""
        try:
            # Kurze I/O-Zeitmessung durchführen
            start = time.time()
            sample_size = 3
            count = 0

            # Prüfe nur, wenn wir keine aktuellen Leistungsmetriken haben
            if time.time() - self.__class__._performance_metrics['last_scan_time'] > 300:
                # Versuche, ein paar Verzeichnisse zu scannen für eine Stichprobe
                with os.scandir(directory) as it:
                    for entry in it:
                        if count >= sample_size or (time.time() - start) > 0.5:
                            break
                        if entry.is_dir():
                            try:
                                list(os.scandir(entry.path))
                                count += 1
                            except (PermissionError, OSError):
                                continue

                # Wenn wir genügend Samples haben, berechne durchschnittliche Latenz
                elapsed = time.time() - start
                if count > 0:
                    avg_latency = elapsed / count
                    self.__class__._performance_metrics['filesystem_latency'] = avg_latency
                    self._adaptive_params['is_slow_filesystem'] = avg_latency > 0.01  # 10ms

                    # Batch-Größe anpassen basierend auf Dateisystemlatenz
                    if self._adaptive_params['is_slow_filesystem']:
                        self._adaptive_params['batch_size_adjusted'] = max(20, self._batch_size // 5)
                    else:
                        self._adaptive_params['batch_size_adjusted'] = self._batch_size
        except Exception:
            # Bei Fehler Standardwerte beibehalten
            pass

    def _should_use_threading(self, directory):
        """Bestimmt, ob Threading für dieses Verzeichnis verwendet werden soll."""
        # Überprüfe, ob Threading aktiviert und sinnvoll ist
        if not self._adaptive_params['threading_enabled'] or self._adaptive_params['is_slow_filesystem']:
            return False

        try:
            # Schnelle Zählung der obersten Verzeichnisebene
            dir_count = 0
            file_count = 0

            with os.scandir(directory) as it:
                for entry in it:
                    try:
                        if entry.is_dir():
                            dir_count += 1
                        elif entry.is_file() and self._is_rom_file(Path(entry.path)):
                            file_count += 1

                        # Früh abbrechen, wenn wir genügend Informationen haben
                        if dir_count >= 10 and file_count >= 100:
                            break
                    except (PermissionError, OSError):
                        continue

            # Benutze Threading, wenn:
            # 1. Genügend Unterverzeichnisse für Parallelisierung (min. 3)
            # 2. Genügend potenzielle Dateien (basierend auf Stichprobe)
            # 3. Kein langsames Dateisystem erkannt wurde
            use_threading = (
                dir_count >= 3 and
                (file_count >= 50 or dir_count >= 8)
            )

            return use_threading

        except Exception:
            # Bei Fehler kein Threading verwenden
            return False

    def _scan_sequential(self, directory, progress_callback=None):
        """Sequentielles Scannen des Verzeichnisses ohne Threading."""
        found_files = []
        file_batch = []
        batch_size = self._adaptive_params['batch_size_adjusted']

        dirs_queue = deque([directory])
        scan_depth = 0
        max_depth = self.__class__._settings['max_scan_depth']

        while dirs_queue and scan_depth < max_depth:
            if self._stop_event and self._stop_event.is_set():
                break

            try:
                current_dir = dirs_queue.popleft()
                self._dir_count += 1

                # Systemverzeichnisse und versteckte Verzeichnisse überspringen
                dir_name = os.path.basename(current_dir)
                if (self.__class__._settings['skip_system_dirs'] and
                    dir_name in self.__class__._ignored_dirs):
                    continue

                if (self.__class__._settings['skip_hidden_dirs'] and
                    dir_name.startswith('.') and dir_name != '.'):
                    continue

                try:
                    # Effizienteres Verzeichnisscannen mit scandir
                    with os.scandir(current_dir) as it:
                        subdirs = []

                        for entry in it:
                            if self._stop_event and self._stop_event.is_set():
                                break

                            try:
                                # Effiziente Überprüfung auf Verzeichnis oder Datei
                                if entry.is_dir():
                                    # Sammle Unterverzeichnisse für späteres Hinzufügen
                                    subdirs.append(entry.path)
                                elif entry.is_file():
                                    file_path = Path(entry.path)
                                    if self._is_rom_file(file_path):
                                        file_batch.append(file_path)
                                        self._file_count += 1

                                        # In Batches für bessere Leistung verarbeiten
                                        if len(file_batch) >= batch_size:
                                            found_files.extend(file_batch)
                                            file_batch = []

                                        # Adaptive Berichtsintervalle
                                        current_time = time.time()
                                        should_report = (
                                            self._file_count % self._progress_interval == 0 or
                                            current_time - self._progress_last_time >= 0.2
                                        )

                                        if progress_callback and should_report:
                                            progress_callback(self._file_count)
                                            self._progress_last_time = current_time

                                            # Berichtsintervall basierend auf Dateizahl anpassen
                                            if self._file_count > 10000:
                                                self._progress_interval = 500
                                            elif self._file_count > 1000:
                                                self._progress_interval = 100
                            except (PermissionError, OSError):
                                # Dateien/Verzeichnisse überspringen, auf die wir nicht zugreifen können
                                continue

                        # Unterverzeichnisse hinzufügen, nachdem die aktuelle Verzeichnisebene gescannt wurde
                        dirs_queue.extend(subdirs)

                except (PermissionError, OSError):
                    # Verzeichnisse überspringen, auf die wir nicht zugreifen können
                    continue

            except IndexError:
                # Queue ist leer, erhöhe die Tiefenstufe
                scan_depth += 1

        # Verbleibende Dateien im Batch hinzufügen
        if file_batch:
            found_files.extend(file_batch)

        return found_files

    def _scan_with_threading(self, directory, progress_callback=None):
        """Parallelisiertes Scannen des Verzeichnisses mit Threading."""
        found_files = []
        all_dirs = []

        # Zuerst erste Verzeichnisebene scannen, um Arbeit zu verteilen
        try:
            with os.scandir(directory) as it:
                for entry in it:
                    if entry.is_dir():
                        dir_name = os.path.basename(entry.path)

                        # Systemverzeichnisse und versteckte Verzeichnisse überspringen
                        if ((self.__class__._settings['skip_system_dirs'] and
                             dir_name in self.__class__._ignored_dirs) or
                            (self.__class__._settings['skip_hidden_dirs'] and
                             dir_name.startswith('.') and dir_name != '.')):
                            continue

                        all_dirs.append(entry.path)
                    elif entry.is_file():
                        # Dateien in der Wurzel direkt überprüfen
                        file_path = Path(entry.path)
                        if self._is_rom_file(file_path):
                            found_files.append(file_path)
                            self._file_count += 1
        except (PermissionError, OSError):
            # Bei Problemen mit dem Wurzelverzeichnis zum sequentiellen Scannen zurückkehren
            return self._scan_sequential(directory, progress_callback)

        if not all_dirs:
            # Wenn keine Unterverzeichnisse vorhanden sind, verwende sequentielles Scannen
            return self._scan_sequential(directory, progress_callback)

        # Bereite Thread-Pool vor
        max_threads = min(len(all_dirs), self.__class__._settings['max_threads'])
        if max_threads <= 1:
            # Nicht genügend Verzeichnisse für effektives Threading
            return self._scan_sequential(directory, progress_callback)

        # Verteile Verzeichnisse an Worker-Threads
        chunks = self._create_balanced_dir_chunks(all_dirs, max_threads)

        # Erstelle und starte Threads
        threads = []
        for i, chunk in enumerate(chunks):
            thread = threading.Thread(
                target=self._thread_scan_worker,
                args=(chunk, i, progress_callback),
                name=f"Scanner-{i}"
            )
            thread.daemon = True
            threads.append(thread)
            thread.start()

        # Warte auf alle Threads
        for thread in threads:
            thread.join()

        # Fehler überprüfen
        if self._thread_error:
            logging.error(f"Thread-Fehler aufgetreten: {self._thread_error}")
            # Fallback zum sequentiellen Scannen bei Thread-Fehlern
            return self._scan_sequential(directory, progress_callback)

        # Ergebnisse zusammenführen
        for result in self._thread_results:
            found_files.extend(result)

        return found_files

    def _thread_scan_worker(self, dirs, thread_id, progress_callback):
        """Worker-Thread zum Scannen einer Liste von Verzeichnissen."""
        try:
            with self._thread_lock:
                self._active_threads += 1

            thread_files = []
            file_batch = []
            local_file_count = 0
            batch_size = self._adaptive_params['batch_size_adjusted']
            last_progress_time = time.time()

            for directory in dirs:
                if self._stop_event and self._stop_event.is_set():
                    break

                # Verwende eine angepasste Tiefensuche für diesen Thread
                dirs_stack = [directory]
                scan_depth = 0
                max_depth = self.__class__._settings['max_scan_depth']

                while dirs_stack and scan_depth < max_depth:
                    if self._stop_event and self._stop_event.is_set():
                        break

                    try:
                        current_dir = dirs_stack.pop()

                        # Verzeichnisname überprüfen
                        dir_name = os.path.basename(current_dir)
                        if ((self.__class__._settings['skip_system_dirs'] and
                             dir_name in self.__class__._ignored_dirs) or
                            (self.__class__._settings['skip_hidden_dirs'] and
                             dir_name.startswith('.') and dir_name != '.')):
                            continue

                        with self._thread_lock:
                            self._dir_count += 1

                        # Verzeichnis scannen
                        try:
                            with os.scandir(current_dir) as it:
                                subdirs = []

                                for entry in it:
                                    if self._stop_event and self._stop_event.is_set():
                                        break

                                    try:
                                        if entry.is_dir():
                                            subdirs.append(entry.path)
                                        elif entry.is_file():
                                            file_path = Path(entry.path)
                                            if self._is_rom_file(file_path):
                                                file_batch.append(file_path)
                                                local_file_count += 1

                                                # Batch verarbeiten
                                                if len(file_batch) >= batch_size:
                                                    thread_files.extend(file_batch)
                                                    file_batch = []

                                                    # Fortschritt melden (thread-sicher)
                                                    current_time = time.time()
                                                    if current_time - last_progress_time >= 0.5:
                                                        with self._thread_lock:
                                                            self._file_count += local_file_count
                                                            if progress_callback:
                                                                progress_callback(self._file_count)
                                                        local_file_count = 0
                                                        last_progress_time = current_time
                                    except (PermissionError, OSError):
                                        continue

                                # Unterverzeichnisse zum Stack hinzufügen
                                dirs_stack.extend(reversed(subdirs))  # Umgekehrte Reihenfolge für DFS
                        except (PermissionError, OSError):
                            continue

                    except IndexError:
                        scan_depth += 1

            # Verbleibende Dateien verarbeiten
            if file_batch:
                thread_files.extend(file_batch)

            # Letzte Fortschrittsaktualisierung
            with self._thread_lock:
                self._file_count += local_file_count
                if progress_callback:
                    progress_callback(self._file_count)
                self._thread_results.append(thread_files)
                self._active_threads -= 1

        except Exception as e:
            with self._thread_lock:
                self._thread_error = e
                self._active_threads -= 1

    def _create_balanced_dir_chunks(self, dirs, num_chunks):
        """Erstellt ausgeglichene Verzeichnis-Chunks für Multi-Threading."""
        # Wenn nur wenige Verzeichnisse, einfach gleichmäßig aufteilen
        if len(dirs) <= num_chunks * 2:
            return [dirs[i::num_chunks] for i in range(num_chunks)]

        # Für eine ausgewogenere Verteilung, versuche Verzeichnisgrößen zu schätzen
        dir_sizes = []
        for d in dirs:
            try:
                # Schätze Verzeichnisgröße durch Zählen der Einträge auf oberster Ebene
                size = sum(1 for _ in os.scandir(d))
                dir_sizes.append((d, size))
            except (PermissionError, OSError):
                dir_sizes.append((d, 1))  # Minimalgröße für unzugängliche Verzeichnisse

        # Sortiere Verzeichnisse nach geschätzter Größe (absteigend)
        dir_sizes.sort(key=lambda x: x[1], reverse=True)

        # Verteile nach Greedy-Algorithmus (größte zuerst)
        chunks = [[] for _ in range(num_chunks)]
        chunk_sizes = [0] * num_chunks

        for dir_path, size in dir_sizes:
            # Finde Chunk mit geringster aktueller Größe
            min_idx = chunk_sizes.index(min(chunk_sizes))
            chunks[min_idx].append(dir_path)
            chunk_sizes[min_idx] += size

        return chunks

    def _adjust_adaptive_parameters(self, files_per_second, dirs_scanned, total_time):
        """Passt adaptive Parameter für künftige Scans basierend auf Leistungsmetriken an."""
        try:
            # Batch-Größe anpassen
            if files_per_second > 1000:
                # Sehr schnelles Dateisystem
                self._batch_size = min(500, self._batch_size * 1.5)
            elif files_per_second < 100:
                # Langsames Dateisystem
                self._batch_size = max(20, self._batch_size * 0.8)

            # Threading-Entscheidung anpassen
            if dirs_scanned < 10 or total_time < 1.0:
                # Kleine Verzeichnisstruktur - Threading deaktivieren
                self._adaptive_params['threading_enabled'] = False
            elif dirs_scanned > 100 and total_time > 5.0 and files_per_second > 200:
                # Große Verzeichnisstruktur mit guter Leistung - Threading aktivieren
                self._adaptive_params['threading_enabled'] = True

        except Exception:
            # Bei Fehlern Parameter nicht ändern
            pass

    @classmethod
    def clear_cache(cls):
        """Clear the scan cache."""
        with cls._cache_lock:
            cls._scan_cache.clear()
            cls._cache_hit_count = 0
            cls._cache_miss_count = 0

    @property
    def cache_stats(self):
        """Return cache statistics."""
        with self._cache_lock:
            return {
                'hits': self._cache_hit_count,
                'misses': self._cache_miss_count,
                'entries': len(self._scan_cache),
                'hit_ratio': self._cache_hit_count / max(1, self._cache_hit_count + self._cache_miss_count)
            }

# ============================================================================
# MAIN GUI CLASS
# ============================================================================

class OptimizedROMSorterGUI:
    """Optimized main GUI class with memory management."""

    # Console detection lookup table
    CONSOLE_MAP = {
        # Nintendo Handhelds
        '.gb': 'Nintendo_Game_Boy', '.sgb': 'Nintendo_Game_Boy', '.dmg': 'Nintendo_Game_Boy',
        '.gbc': 'Nintendo_Game_Boy_Color',
        '.gba': 'Nintendo_Game_Boy_Advance', '.agb': 'Nintendo_Game_Boy_Advance', '.mb': 'Nintendo_Game_Boy_Advance',
        '.nds': 'Nintendo_DS', '.dsi': 'Nintendo_DS',
        '.3ds': 'Nintendo_3DS', '.cia': 'Nintendo_3DS', '.3dsx': 'Nintendo_3DS', '.cci': 'Nintendo_3DS', '.cxi': 'Nintendo_3DS', '.app': 'Nintendo_3DS',

        # Nintendo Home Consoles
        '.nes': 'Nintendo_NES', '.unf': 'Nintendo_NES', '.unif': 'Nintendo_NES', '.fds': 'Nintendo_NES', '.nsf': 'Nintendo_NES', '.qd': 'Nintendo_NES',
        '.snes': 'Super_Nintendo', '.smc': 'Super_Nintendo', '.sfc': 'Super_Nintendo', '.fig': 'Super_Nintendo', '.swc': 'Super_Nintendo', '.st': 'Super_Nintendo', '.bs': 'Super_Nintendo',
        '.n64': 'Nintendo_64', '.v64': 'Nintendo_64', '.z64': 'Nintendo_64', '.u64': 'Nintendo_64', '.jst': 'Nintendo_64', '.mpk': 'Nintendo_64', '.fla': 'Nintendo_64',
        '.gcm': 'Nintendo_GameCube', '.gcz': 'Nintendo_GameCube', '.rvz': 'Nintendo_GameCube', '.wia': 'Nintendo_GameCube', '.ciso': 'Nintendo_GameCube', '.dol': 'Nintendo_GameCube', '.elf': 'Nintendo_GameCube',
        '.wbfs': 'Nintendo_Wii', '.wad': 'Nintendo_Wii', '.u8': 'Nintendo_Wii', '.tmd': 'Nintendo_Wii', '.tik': 'Nintendo_Wii',
        '.wud': 'Nintendo_Wii_U', '.wux': 'Nintendo_Wii_U', '.rpx': 'Nintendo_Wii_U', '.rpl': 'Nintendo_Wii_U', '.wua': 'Nintendo_Wii_U',
        '.xci': 'Nintendo_Switch', '.nsp': 'Nintendo_Switch', '.nsz': 'Nintendo_Switch', '.kip': 'Nintendo_Switch', '.nca': 'Nintendo_Switch', '.cert': 'Nintendo_Switch',

        # Sony Consoles
        '.iso': 'PlayStation', '.bin': 'PlayStation', '.img': 'PlayStation', '.mdf': 'PlayStation', '.cue': 'PlayStation', '.ecm': 'PlayStation',
        '.mds': 'PlayStation_2', '.nrg': 'PlayStation_2', '.chd': 'PlayStation_2', '.cso': 'PlayStation_2',
        '.pkg': 'PlayStation_3', '.psn': 'PlayStation_3', '.p3t': 'PlayStation_3',
        '.pup': 'PlayStation_4', '.gp4': 'PlayStation_4',
        '.psp': 'PlayStation_Portable', '.pbp': 'PlayStation_Portable', '.cso': 'PlayStation_Portable',
        '.vpk': 'PlayStation_Vita', '.psvgz': 'PlayStation_Vita',

        # Sega Consoles
        '.sms': 'Sega_Master_System', '.sg': 'Sega_Master_System', '.sc': 'Sega_Master_System', '.mv': 'Sega_Master_System',
        '.gg': 'Sega_Game_Gear',
        '.md': 'Sega_Genesis', '.gen': 'Sega_Genesis', '.smd': 'Sega_Genesis', '.sgd': 'Sega_Genesis', '.68k': 'Sega_Genesis',
        '.32x': 'Sega_32X',
        '.scd': 'Sega_CD',
        '.gdi': 'Sega_Dreamcast', '.cdi': 'Sega_Dreamcast', '.chd': 'Sega_Dreamcast',
        '.sat': 'Sega_Saturn',
        '.naomi': 'Sega_NAOMI',

        # Microsoft Consoles
        '.xbe': 'Xbox',
        '.xex': 'Xbox_360',
        '.xvd': 'Xbox_One',
        '.xvc': 'Xbox_Series',

        # Atari Consoles
        '.a26': 'Atari_2600', '.bin': 'Atari_2600',
        '.a52': 'Atari_5200',
        '.a78': 'Atari_7800',
        '.lnx': 'Atari_Lynx', '.lyx': 'Atari_Lynx', '.o': 'Atari_Lynx',
        '.jag': 'Atari_Jaguar', '.j64': 'Atari_Jaguar',
        '.ate': 'Atari_8bit',
        '.ast': 'Atari_ST',

        # NEC Consoles
        '.pce': 'PC_Engine', '.sgx': 'PC_Engine',
        '.pc98': 'NEC_PC98',
        '.pc88': 'NEC_PC88',
        '.sgx': 'SuperGrafx',

        # SNK Consoles
        '.neo': 'Neo_Geo',
        '.ngp': 'Neo_Geo_Pocket',
        '.ngc': 'Neo_Geo_Pocket_Color',
        '.mvs': 'Neo_Geo_MVS',
        '.aes': 'Neo_Geo_AES',

        # Computer Systems
        '.adf': 'Amiga', '.adz': 'Amiga', '.dms': 'Amiga', '.ipf': 'Amiga', '.hdf': 'Amiga',
        '.d64': 'Commodore_64', '.t64': 'Commodore_64', '.tap': 'Commodore_64', '.prg': 'Commodore_64', '.p00': 'Commodore_64', '.crt': 'Commodore_64',
        '.d71': 'Commodore_128', '.d81': 'Commodore_128',
        '.dsk': 'Apple_II', '.nib': 'Apple_II', '.po': 'Apple_II', '.do': 'Apple_II',
        '.st': 'Atari_ST', '.msa': 'Atari_ST', '.stx': 'Atari_ST',
        '.tap': 'ZX_Spectrum', '.tzx': 'ZX_Spectrum', '.z80': 'ZX_Spectrum', '.sna': 'ZX_Spectrum',
        '.mgt': 'MSX', '.rom': 'MSX', '.mx1': 'MSX', '.mx2': 'MSX', '.cas': 'MSX_Cassette',
        '.bas': 'BBC_Micro', '.uef': 'BBC_Micro', '.ssd': 'BBC_Micro', '.dsd': 'BBC_Micro',
        '.cpc': 'Amstrad_CPC', '.dsk': 'Amstrad_CPC', '.cdt': 'Amstrad_CPC',
        '.atr': 'Atari_8bit', '.xex': 'Atari_8bit', '.dcm': 'Atari_8bit',

        # Additional Modern Consoles
        '.3dsx': '3DS_Homebrew',
        '.nacp': 'Nintendo_Switch',
        '.psarc': 'PlayStation_Library',

        # Arcade Systems - Deutlich erweitert
        '.zip': 'MAME_Arcade',
        '.chd': 'MAME_Arcade',
        '.7z': 'MAME_Arcade',  # MAME unterstützt auch 7z-Archive

        # Spezielle Arcade-Systeme
        '.capcom': 'Capcom_CPS1',
        '.cps1': 'Capcom_CPS1',
        '.cps2': 'Capcom_CPS2',
        '.cps3': 'Capcom_CPS3',
        '.neogeo': 'Neo_Geo_MVS',
        '.pgm': 'IGS_PGM',
        '.cave': 'Cave',
        '.taito': 'Taito',
        '.konami': 'Konami',
        '.irem': 'Irem',
        '.sega': 'Sega_Arcade',
        '.naomi': 'Sega_NAOMI',
        '.atomiswave': 'Sammy_Atomiswave',
        '.model1': 'Sega_Model1',
        '.model2': 'Sega_Model2',
        '.model3': 'Sega_Model3',
        '.namco': 'Namco',
        '.system22': 'Namco_System22',
        '.system246': 'Namco_System246',
        '.triforce': 'Triforce',
        '.type_x': 'Taito_TypeX',

        # Additional formats and Handhelds
        '.col': 'ColecoVision',
        '.int': 'Intellivision',
        '.vb': 'Virtual_Boy',
        '.vec': 'Vectrex',
        '.ws': 'WonderSwan',
        '.wsc': 'WonderSwan_Color',
        '.pce': 'PC_Engine',
        '.sgx': 'SuperGrafx',
        '.gcce': 'Tiger_Game_Com',
        '.lnx': 'Atari_Lynx',
        '.ngp': 'Neo_Geo_Pocket',
        '.ngc': 'Neo_Geo_Pocket_Color',
        '.srm': 'Supervision',
        '.bin': 'Binary',
        '.rom': 'ROM_File',
        '.img': 'Disk_Image',

        # FM Towns und ähnliche Systeme
        '.fdi': 'FM_Towns',
        '.mfi': 'FM_Towns',
        '.mdx': 'Sharp_X68000',
        '.dim': 'Sharp_X68000',
        '.hdm': 'Sharp_X68000',
        '.xdf': 'Sharp_X68000',

        # PC-Formate
        '.exe': 'PC_DOS',
        '.com': 'PC_DOS',
        '.ima': 'PC_DOS',
        '.img': 'PC_DOS',
        '.vhd': 'PC_Windows',
        '.gog': 'PC_GOG',

        # Sharp, NEC und andere japanische Computer
        '.2mg': 'Apple_Macintosh',
        '.pc98': 'NEC_PC98',
        '.hdi': 'NEC_PC98',
        '.thd': 'NEC_PC98',
        '.nhd': 'NEC_PC98',
        '.hdd': 'NEC_PC98',
        '.pc88': 'NEC_PC88',
        '.d88': 'NEC_PC88',
        '.fdi': 'NEC_PC88',
        '.hdm': 'Sharp_X68000',
        '.xdf': 'Sharp_X68000',
        '.2hd': 'Sharp_X68000',
        '.cmd': 'MSX_DOS',

        # Modernes Arcade und Flash
        '.jamma': 'JAMMA',
        '.swf': 'Adobe_Flash',
        '.fla': 'Adobe_Flash',
        '.air': 'Adobe_AIR',

        # Allgemeine Archive (niedrigste Priorität)
        '.zip': 'Archive',
        '.7z': 'Archive',
        '.rar': 'Archive',
        '.tar': 'Archive',
        '.gz': 'Archive'
    }

    def __init__(self):
        self._initialize_window()
        self._initialize_variables()
        self._create_menu()  # Menüleiste hinzugefügt
        self._create_interface()
        self._initialize_workers()
        self._initialize_theme_support()  # Theme-System initialisieren

        # Setup cleanup
        self.root.protocol("WM_DELETE_WINDOW", self._on_closing)
        atexit.register(self._cleanup_all)

    def _initialize_window(self):
        """Initialize main window with optimal performance settings."""
        # Erstelle das Hauptfenster basierend auf der verfügbaren Drag & Drop-Unterstützung
        if DND_AVAILABLE:
            try:
                print(f"Erstelle Root-Fenster mit Drag & Drop-Unterstützung (Modus: {DND_MODE})...")

                if DND_MODE == "tkdnd":
                    # Verwende TkinterDnD
                    from tkinterdnd2 import TkinterDnD
                    self.root = TkinterDnD.Tk()

                    # Überprüfe, ob TkinterDnD korrekt initialisiert wurde
                    if hasattr(self.root, 'TkdndVersion'):
                        print(f"TkinterDnD Version: {self.root.TkdndVersion}")
                    else:
                        print("Warnung: TkinterDnD scheint nicht richtig initialisiert zu sein")
                else:
                    # Erstelle ein Standard-Tk-Fenster für native Drag & Drop
                    self.root = tk.Tk()

                    # Patche das Fenster für plattformübergreifende Drag & Drop-Unterstützung
                    from src.dnd_support import patch_tkinter_root
                    patch_tkinter_root(self.root)
                    print("Root-Fenster für native Drag & Drop gepatcht")

            except Exception as e:
                print(f"Fehler beim Erstellen des Fensters mit Drag & Drop-Unterstützung: {e}")
                import traceback
                traceback.print_exc()

                # Fallback auf Standard-Tk-Fenster
                self.root = tk.Tk()
                globals()['DND_AVAILABLE'] = False
                globals()['DND_MODE'] = "none"

        else:
            # Kein Drag & Drop verfügbar
            self.root = tk.Tk()

        self.root.title("ROM Sorter Pro 🎮 - Optimized v2.1.4")
        self.root.geometry("1000x700")
        self.root.minsize(800, 600)

        # Improve rendering performance
        # Disable useless extension that can cause flickering
        self.root.tk.call('package', 'forget', 'Tk_syncLed')

        # Increase the synchronization delay for smoother updates
        self.root.tk.call('tk', 'useinputmethods', '1')
        self.root.tk.call('tk', 'scaling', '1.0')  # Consistent scaling

        # Set resource-usage flags for better performance
        if platform.system() == "Windows":
            try:
                # Windows-specific optimizations
                self.root.iconbitmap(default="assets/icon.ico")
                # Use hardware acceleration if available
                self.root.tk.call('tk', 'scaling', self.root.winfo_fpixels('1i')/72.0)
            except:
                pass

        # Set color depth optimization
        try:
            self.root.tk.call('tk', 'useinputmethods', '1')
            self.root.tk.call('image', 'create', 'photo', 'empty', '-width', '1', '-height', '1')
        except:
            pass

        # Optimize for responsiveness
        self.root.update_idletasks()

        # Enable drag & drop on root if available
        if DND_AVAILABLE and hasattr(self.root, 'drop_target_register'):
            try:
                self.root.drop_target_register(DND_FILES)
                # Add drop binding
                self.root.dnd_bind('<<Drop>>', self._handle_root_drop)
            except:
                pass

        # Configure better default cursor
        self.root.configure(cursor="arrow")

    def _handle_root_drop(self, event):
        """Behandle Drag & Drop-Ereignisse im Hauptfenster mit robuster Pfadextraktion."""
        try:
            print(f"Root-Drop-Event empfangen: {event}")

            if not hasattr(event, 'data') or not event.data:
                print("Root-Drop-Event hat keine Daten")
                return

            # Verwende die verbesserte Pfadextraktion
            paths = self._extract_drop_paths(event.data)

            if not paths:
                print("Keine gültigen Pfade im Root-Drop gefunden")
                return

            # Suche zuerst nach gültigen Verzeichnissen
            for path in paths:
                if os.path.exists(path) and os.path.isdir(path):
                    print(f"Root-Drop: Gültiges Verzeichnis gefunden: {path}")
                    self._set_source_folder(path)
                    # Zeige visuelles Feedback
                    self._show_drag_drop_feedback(f"📁 {os.path.basename(path)} ausgewählt")
                    return

            # Dann versuche Elternverzeichnisse von Dateien
            for path in paths:
                if os.path.exists(path) and os.path.isfile(path):
                    parent_dir = os.path.dirname(path)
                    if os.path.exists(parent_dir) and os.path.isdir(parent_dir):
                        print(f"Root-Drop: Verwende Elternverzeichnis: {parent_dir}")
                        self._set_source_folder(parent_dir)
                        # Zeige visuelles Feedback
                        self._show_drag_drop_feedback(f"📁 {os.path.basename(parent_dir)} ausgewählt")
                        return

        except Exception as e:
            print(f"Fehler bei Root-Drop-Verarbeitung: {e}")
            import traceback
            traceback.print_exc()

    def _extract_drop_paths(self, data):
        """Extrahiert Pfade aus Drop-Daten - wiederverwendbare Methode für verschiedene Drop-Ziele."""
        try:
            # Verwende die vorhandene Implementierung in OptimizedDragDropFrame
            from inspect import getmembers, ismethod

            # Suche nach einer Instanz von OptimizedDragDropFrame in den untergeordneten Widgets
            for child in self.root.winfo_children():
                if isinstance(child, OptimizedDragDropFrame):
                    return child._extract_paths_from_drop(data)

            # Fallback: Eigene einfache Implementierung
            if isinstance(data, str):
                # Für Windows Explorer Format
                if os.name == 'nt' and data.startswith('{') and data.endswith('}'):
                    path = data.strip('{}')
                    if os.path.exists(path):
                        return [path]

                # Normaler Fall - teile am Leerzeichen
                return [p.strip('"\'{}').strip() for p in data.split()]

            return [str(data)]

        except Exception as e:
            print(f"Fehler bei der Root-Drop-Pfadextraktion: {e}")
            return []

    def _show_drag_drop_feedback(self, message):
        """Zeigt ein kurzes visuelles Feedback für Drag & Drop-Operationen."""
        try:
            # Erstelle ein temporäres Label für Feedback
            feedback = tk.Label(
                self.root,
                text=message,
                font=STYLE.fonts['heading'],
                fg=STYLE.colors['text_primary'],
                bg=STYLE.colors['success'],
                padx=20,
                pady=10,
                relief="raised",
                borderwidth=2
            )

            # Positioniere in der Mitte des Fensters
            feedback.place(relx=0.5, rely=0.5, anchor="center")

            # Animiere das Ausblenden
            def fade_out(alpha=1.0):
                if alpha > 0:
                    feedback.configure(bg=f"#{int(40 + (1-alpha)*215):02x}{int(167 + (1-alpha)*88):02x}{int(69 + (1-alpha)*186):02x}")
                    self.root.after(50, lambda: fade_out(alpha - 0.1))
                else:
                    feedback.destroy()

            # Starte Ausblenden nach 1 Sekunde
            self.root.after(1000, fade_out)

        except Exception as e:
            print(f"Fehler beim Anzeigen des Feedbacks: {e}")

    def _create_menu(self):
        """Erstellt die Hauptmenüleiste."""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # Datei-Menü
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="Quellordner öffnen...", command=self._select_source_folder)
        file_menu.add_command(label="Zielordner öffnen...", command=self._select_dest_folder)
        file_menu.add_separator()
        file_menu.add_command(label="Beenden", command=self._on_closing)
        menubar.add_cascade(label="Datei", menu=file_menu)

        # Aktionen-Menü
        action_menu = tk.Menu(menubar, tearoff=0)
        action_menu.add_command(label="ROM-Sortierung starten", command=self._start_sorting)
        action_menu.add_command(label="Sortierung abbrechen", command=self._cancel_sorting)
        action_menu.add_separator()
        action_menu.add_command(label="Log-Datei öffnen", command=self._open_log_file)
        menubar.add_cascade(label="Aktionen", menu=action_menu)

        # Datenbank-Menü (neu)
        db_menu = tk.Menu(menubar, tearoff=0)
        db_menu.add_command(label="Datenbank-Status anzeigen", command=self._display_database_status)
        db_menu.add_command(label="ROM-Datenbank verwalten", command=self._show_database_manager)
        db_menu.add_separator()
        db_menu.add_command(label="Dokumentation zu Datenbanken", command=self._show_database_docs)
        menubar.add_cascade(label="Datenbank", menu=db_menu)

        # Einstellungen-Menü (mit Theme-Optionen)
        settings_menu = tk.Menu(menubar, tearoff=0)
        settings_menu.add_command(label="Allgemeine Einstellungen", command=self._show_settings)

        # Theme-Untermenü
        if THEME_SUPPORT and hasattr(self, 'theme_integrator') and self.theme_integrator:
            theme_menu = tk.Menu(settings_menu, tearoff=0)

            # Füge alle verfügbaren Themes hinzu
            if hasattr(self.theme_integrator, 'theme_manager'):
                theme_names = self.theme_integrator.theme_manager.get_theme_names()
                current_theme = self.theme_integrator.theme_manager.get_current_theme_name()

                for theme_name in theme_names:
                    theme_menu.add_radiobutton(
                        label=theme_name,
                        command=lambda tn=theme_name: self._change_theme(tn),
                        variable=tk.StringVar(value=current_theme),
                        value=theme_name
                    )

            theme_menu.add_separator()
            theme_menu.add_command(label="Theme anpassen...", command=self._customize_theme)
            settings_menu.add_cascade(label="Theme", menu=theme_menu)

        menubar.add_cascade(label="Einstellungen", menu=settings_menu)

        # Hilfe-Menü
        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="Hilfe anzeigen", command=self._show_help)
        help_menu.add_command(label="Über ROM Sorter Pro", command=self._show_about)
        menubar.add_cascade(label="Hilfe", menu=help_menu)

    def _initialize_theme_support(self):
        """Initialisiert das Theme-System."""
        if THEME_SUPPORT:
            try:
                self.theme_integrator = ThemeIntegrator(self)
                print("Theme-System erfolgreich initialisiert")
            except Exception as e:
                print(f"Fehler beim Initialisieren des Theme-Systems: {e}")
                self.theme_integrator = None
        else:
            self.theme_integrator = None
            print("Theme-System nicht verfügbar")

    def _initialize_variables(self):
        """Initialize GUI variables."""
        self.source_folder = tk.StringVar()
        self.dest_folder = tk.StringVar()
        self.console_mode = tk.BooleanVar(value=True)
        self.is_running = False
        self.worker_thread = None
        self._cleanup_callbacks = []
        self.stop_requested = threading.Event()  # Event für die Abbruch-Anforderung

    def _show_settings(self):
        """Zeigt den Dialog mit den allgemeinen Einstellungen an."""
        settings_window = tk.Toplevel(self.root)
        settings_window.title("Einstellungen")
        settings_window.geometry("500x400")
        settings_window.transient(self.root)
        settings_window.grab_set()

        # Hauptframe
        main_frame = tk.Frame(settings_window)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # Allgemeine Einstellungen
        general_frame = tk.LabelFrame(main_frame, text="Allgemeine Einstellungen")
        general_frame.pack(fill="x", pady=10)

        # Logging-Level
        log_frame = tk.Frame(general_frame)
        log_frame.pack(fill="x", pady=5)

        tk.Label(log_frame, text="Log-Level:").pack(side="left")
        log_level = tk.StringVar(value="INFO")
        log_combo = ttk.Combobox(log_frame, textvariable=log_level,
                                values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
                                state="readonly")
        log_combo.pack(side="right", fill="x", expand=True, padx=(10, 0))

        # Theme-Einstellungen, falls verfügbar
        if THEME_SUPPORT and self.theme_integrator:
            theme_frame = tk.LabelFrame(main_frame, text="Theme-Einstellungen")
            theme_frame.pack(fill="x", pady=10)

            theme_selection = self.theme_integrator.get_theme_selection_frame(theme_frame)
            theme_selection.pack(fill="x", padx=10, pady=10)

        # Button zum Schließen
        ttk.Button(main_frame, text="Schließen", command=settings_window.destroy).pack(pady=10)

    def _change_theme(self, theme_name):
        """
        Ändert das aktuelle Theme.

        Args:
            theme_name: Name des zu verwendenden Themes
        """
        if THEME_SUPPORT and self.theme_integrator:
            self.theme_integrator._change_theme(theme_name)

    def _customize_theme(self):
        """Öffnet den Dialog zur Theme-Anpassung."""
        if THEME_SUPPORT and self.theme_integrator:
            self.theme_integrator._show_theme_customizer()

    def show_notification(self, message, level="info"):
        """
        Zeigt eine Benachrichtigung an.

        Args:
            message: Die Nachricht, die angezeigt werden soll
            level: Der Typ der Nachricht ("info", "warning", "error")
        """
        if level.lower() == "info":
            messagebox.showinfo("Information", message)
        elif level.lower() == "warning":
            messagebox.showwarning("Warnung", message)
        elif level.lower() == "error":
            messagebox.showerror("Fehler", message)
        else:
            messagebox.showinfo("Hinweis", message)

    def _show_about(self):
        """Show about dialog with information about ROM Sorter Pro."""
        about_text = """ROM Sorter Pro v2.2.0 - Theme Edition

Ein professionelles Werkzeug zur Organisation von ROM-Sammlungen.

Features:
- Automatische ROM-Erkennung mit mehreren Detektionsstrategien
- Datenbank-basierte ROM-Identifikation (No-Intro und Redump)
- Verbesserte CHD-Unterstützung
- Drag & Drop-Support
- Multithreading-Performance
- Erweiterte Konsolen-Erkennung

© 2024 ROM Sorter Team. Alle Rechte vorbehalten."""

        messagebox.showinfo("Über ROM Sorter Pro", about_text)

    def _create_interface(self):
        """Create optimized interface."""
        self._setup_styles()

        # Main container
        main_frame = tk.Frame(self.root, bg=STYLE.colors['bg_primary'])
        main_frame.pack(fill='both', expand=True)

        # Header
        self._create_header(main_frame)

        # Content area with paned window
        paned = ttk.PanedWindow(main_frame, orient='horizontal')
        paned.pack(fill='both', expand=True, padx=10, pady=5)

        # Left panel (controls)
        left_frame = tk.Frame(paned, bg=STYLE.colors['bg_secondary'], width=350)
        paned.add(left_frame, weight=1)
        self._create_left_panel(left_frame)

        # Right panel (stats and logs)
        right_frame = tk.Frame(paned, bg=STYLE.colors['bg_secondary'])
        paned.add(right_frame, weight=2)
        self._create_right_panel(right_frame)

        # Footer
        self._create_footer(main_frame)

    def _setup_styles(self):
        """Setup TTK styles."""
        style = ttk.Style()
        try:
            style.theme_use('vista')
        except:
            style.theme_use('clam')

    def _create_header(self, parent):
        """Create header section."""
        header = tk.Frame(parent, bg=STYLE.colors['bg_primary'])
        header.pack(fill='x', padx=10, pady=10)

        # Title
        title_frame = tk.Frame(header, bg=STYLE.colors['bg_primary'])
        title_frame.pack(side='left')

        tk.Label(
            title_frame, text="🎮 ROM Sorter Pro",
            bg=STYLE.colors['bg_primary'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['title']
        ).pack(anchor='w')

        tk.Label(
            title_frame, text="Optimized Universal Console ROM Organizer v2.1.4",
            bg=STYLE.colors['bg_primary'],
            fg=STYLE.colors['text_secondary'],
            font=STYLE.fonts['body']
        ).pack(anchor='w')

        # Action buttons
        btn_frame = tk.Frame(header, bg=STYLE.colors['bg_primary'])
        btn_frame.pack(side='right')

        tk.Button(
            btn_frame, text="❓ Help", command=self._show_help,
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['body'],
            relief='flat', padx=15
        ).pack(side='right', padx=5)

    def _create_left_panel(self, parent):
        """Create left control panel."""
        # Configuration title
        tk.Label(
            parent, text="⚙️ Configuration",
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['heading']
        ).pack(pady=10)

        # Source folder section
        self._create_folder_section(parent, "📂 Source Folder", "source")

        # Destination folder section
        self._create_folder_section(parent, "📁 Destination Folder", "dest")

        # Options
        self._create_options_section(parent)

        # Action buttons
        self._create_action_section(parent)

    def _create_folder_section(self, parent, title: str, folder_type: str):
        """Create folder selection section."""
        frame = tk.Frame(parent, bg=STYLE.colors['bg_secondary'])
        frame.pack(fill='x', padx=10, pady=5)

        tk.Label(
            frame, text=title,
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['body']
        ).pack(anchor='w')

        # Callback based on folder type
        if folder_type == "source":
            callback = self._set_source_folder
            var = self.source_folder
        else:
            callback = self._set_dest_folder
            var = self.dest_folder

        # Drag & drop frame
        drop_frame = OptimizedDragDropFrame(frame, callback=callback, height=50)
        drop_frame.pack(fill='x', pady=5)

        # Selected path label
        path_label = tk.Label(
            frame, textvariable=var,
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_secondary'],
            font=STYLE.fonts['small'],
            wraplength=300
        )
        path_label.pack(anchor='w')

    def _create_options_section(self, parent):
        """Create options section."""
        options_frame = tk.LabelFrame(
            parent, text="🔧 Options",
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['body']
        )
        options_frame.pack(fill='x', padx=10, pady=10)

        tk.Checkbutton(
            options_frame, text="Sort by console (recommended)",
            variable=self.console_mode,
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['body'],
            activebackground=STYLE.colors['bg_secondary'],
            selectcolor=STYLE.colors['bg_accent']
        ).pack(anchor='w', padx=10, pady=5)

    def _create_action_section(self, parent):
        """Create action buttons section."""
        action_frame = tk.Frame(parent, bg=STYLE.colors['bg_secondary'])
        action_frame.pack(fill='x', padx=10, pady=20)

        self.scan_btn = tk.Button(
            action_frame, text="🔍 Preview Scan",
            command=self._start_preview_scan,
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['body'],
            relief='flat', height=2
        )
        self.scan_btn.pack(fill='x', pady=2)

        self.start_btn = tk.Button(
            action_frame, text="▶️ Start Sorting",
            command=self._start_sorting,
            bg=STYLE.colors['success'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['heading'],
            relief='flat', height=2
        )
        self.start_btn.pack(fill='x', pady=2)

        self.stop_btn = tk.Button(
            action_frame, text="⏹️ Stop",
            command=self._stop_operation,
            bg=STYLE.colors['error'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['body'],
            relief='flat', height=2, state='disabled'
        )
        self.stop_btn.pack(fill='x', pady=2)

        # Progress bar
        self.progress_bar = MemoryEfficientProgressBar(action_frame)
        self.progress_bar.pack(fill='x', pady=10)

        self.progress_label = tk.Label(
            action_frame, text="Ready to start",
            bg=STYLE.colors['bg_secondary'],
            fg=STYLE.colors['text_secondary'],
            font=STYLE.fonts['small']
        )
        self.progress_label.pack()

    def _create_right_panel(self, parent):
        """Create right panel with tabs."""
        notebook = ttk.Notebook(parent)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)

        # Statistics tab
        stats_frame = tk.Frame(notebook, bg=STYLE.colors['bg_secondary'])
        notebook.add(stats_frame, text="📊 Statistics")

        self.stats_widget = OptimizedStatsWidget(stats_frame)
        self.stats_widget.pack(fill='both', expand=True)

        # Log tab
        log_frame = tk.Frame(notebook, bg=STYLE.colors['bg_secondary'])
        notebook.add(log_frame, text="📝 Activity Log")

        self.log_widget = EfficientLogWidget(log_frame)
        self.log_widget.pack(fill='both', expand=True)

    def _create_footer(self, parent):
        """Create footer."""
        footer = tk.Frame(parent, bg=STYLE.colors['bg_accent'], height=25)
        footer.pack(fill='x', side='bottom')
        footer.pack_propagate(False)

        # Status-Label für Datenbankstatus und allgemeine Statusmeldungen
        self.status_bar = tk.Label(
            footer, text="ROM Sorter Pro v2.1.4 - Memory Optimized",
            bg=STYLE.colors['bg_accent'],
            fg=STYLE.colors['text_primary'],
            font=STYLE.fonts['small']
        )
        self.status_bar.pack(side='left', padx=10, pady=5)

        # Zeige initial den Datenbankstatus an
        self.root.after(1000, self._display_database_status)

    def _initialize_workers(self):
        """Initialize worker management with resource tracking."""
        # Use optimal number of workers based on system capabilities
        max_workers = min(4, (os.cpu_count() or 4))

        # Create thread pool with efficient resource management
        self.thread_pool = ThreadPoolExecutor(
            max_workers=max_workers,
            thread_name_prefix="GUI",
            initializer=self._thread_initializer
        )

        # Track all workers for proper cleanup
        self._active_workers = set()
        self._workers_lock = threading.RLock()
        self._shutdown_requested = threading.Event()

        # Add shutdown to cleanup callbacks
        self._cleanup_callbacks.append(lambda: self.thread_pool.shutdown(wait=True, cancel_futures=True))

        # File scanner with ROM extensions from the console map
        self.file_scanner = FastFileScanner(extensions=self.CONSOLE_MAP.keys())

    def _thread_initializer(self):
        """Initialize worker thread with proper settings."""
        # Set thread name for better debugging
        threading.current_thread().name = f"GUI-Worker-{threading.get_ident()}"

        # Configure thread-local storage
        thread_local = threading.local()
        thread_local.start_time = time.time()

        # Monitor for shutdown signal
        def check_shutdown():
            return self._shutdown_requested.is_set()

        thread_local.check_shutdown = check_shutdown

    def _select_source_folder(self):
        """Öffnet einen Dialog zur Auswahl des Quellordners."""
        folder = filedialog.askdirectory(
            title="Quellordner mit ROMs auswählen",
            initialdir=self.source_folder.get() or os.path.expanduser("~")
        )
        if folder:
            self._set_source_folder(folder)

    def _select_dest_folder(self):
        """Öffnet einen Dialog zur Auswahl des Zielordners."""
        folder = filedialog.askdirectory(
            title="Zielordner für sortierte ROMs auswählen",
            initialdir=self.dest_folder.get() or os.path.expanduser("~")
        )
        if folder:
            self._set_dest_folder(folder)

    def _set_source_folder(self, folder: str):
        """Set source folder."""
        if os.path.exists(folder):
            self.source_folder.set(folder)
            self.log_widget.add_log(f"📂 Source: {os.path.basename(folder)}", "SUCCESS")
        else:
            self.log_widget.add_log(f"Source folder not found: {folder}", "ERROR")

    def _set_dest_folder(self, folder: str):
        """Set destination folder."""
        if os.path.exists(folder):
            self.dest_folder.set(folder)
            self.log_widget.add_log(f"📁 Destination: {os.path.basename(folder)}", "SUCCESS")
        else:
            self.log_widget.add_log(f"Destination folder not found: {folder}", "ERROR")

    def _start_preview_scan(self):
        """Start preview scan in background."""
        if not self.source_folder.get():
            messagebox.showerror("Error", "Please select a source folder first.")
            return

        if self.is_running:
            self.log_widget.add_log("Another operation is running", "WARNING")
            return

        self._set_running_state(True)
        self.log_widget.add_log("Starting preview scan...", "INFO")

        # Create a shared state object for better worker coordination
        scan_state = {
            'total_files': 0,
            'processed_files': 0,
            'start_time': time.time(),
            'cancel_requested': False,
            'stats': Counter(),
            'lock': threading.RLock()
        }

        # Create stop event for coordinated termination
        stop_event = threading.Event()

        def scan_worker():
            try:
                # Start scan with animation
                self.progress_bar.start_animation()

                # Log start with timestamp
                source_dir = self.source_folder.get()
                self.root.after(0, lambda: self.log_widget.add_log(
                    f"Scanning directory: {os.path.basename(source_dir)}", "INFO"))

                # Scan for files with progress tracking
                found_files = self.file_scanner.scan_directory(
                    source_dir,
                    progress_callback=lambda count: self._update_scan_progress(count, scan_state),
                    stop_event=stop_event,
                    use_cache=True  # Use caching for better performance
                )

                # Don't continue if cancelled
                if stop_event.is_set():
                    return

                # Analyze files in batches for better responsiveness
                with scan_state['lock']:
                    scan_state['total_files'] = len(found_files)

                # Process in batches of 200 files
                batch_size = 200
                for i in range(0, len(found_files), batch_size):
                    if stop_event.is_set():
                        break

                    batch = found_files[i:i+batch_size]
                    batch_stats = self._analyze_files(batch)

                    with scan_state['lock']:
                        # Update progress
                        scan_state['processed_files'] += len(batch)
                        # Update stats
                        for console, count in batch_stats.items():
                            scan_state['stats'][console] += count

                    # Report progress
                    progress = min(90, (scan_state['processed_files'] / max(scan_state['total_files'], 1)) * 80)
                    self.root.after(0, lambda p=progress: self.progress_bar.update_throttled(p))

                    # Yield to main thread occasionally
                    time.sleep(0.001)

                # Update UI with final results if not cancelled
                if not stop_event.is_set():
                    self.root.after(0, self._scan_complete, dict(scan_state['stats']), scan_state['total_files'])

            except Exception as e:
                self.root.after(0, self._scan_error, str(e))

        # Create worker thread with cleanup handler
        self.worker_thread = SmartThread(target=scan_worker)
        self.worker_thread.add_cleanup_callback(lambda: stop_event.set())
        self.worker_thread.start()

        # Store stop event for cancellation
        self.worker_thread.stop_event = stop_event

    def _analyze_files(self, files: List[Path]) -> Dict[str, int]:
        """Analyze files for console distribution with parallel processing."""
        if not files:
            return {}

        # For small file sets, use simple processing
        if len(files) < 500:
            console_counts = Counter()

            for file_path in files:
                ext = file_path.suffix.lower()

                # Verbesserte Konsolenerkennung
                console = 'Unknown'

                # Spezialbehandlung für Dateien mit mehrdeutigen Erweiterungen
                if ext in ('.bin', '.iso', '.img', '.cue', '.chd', '.rom'):
                    # Bei mehrdeutigen Erweiterungen versuchen wir, aus dem Dateinamen oder dem übergeordneten Ordner
                    # weitere Hinweise zu bekommen
                    filename_lower = file_path.name.lower()
                    parent_dir = file_path.parent.name.lower()

                    # Konsolenspezifische Schlüsselwörter in Dateinamen oder Ordnernamen prüfen
                    console_keywords = {
                        'PlayStation': ['ps1', 'psx', 'playstation', 'sony ps'],
                        'PlayStation_2': ['ps2', 'playstation 2', 'sony ps2'],
                        'PlayStation_3': ['ps3', 'playstation 3', 'sony ps3'],
                        'Sega_Saturn': ['saturn', 'sega saturn'],
                        'Sega_Dreamcast': ['dreamcast', 'sega dreamcast', 'dc'],
                        'Nintendo_GameCube': ['gamecube', 'gcn', 'gc'],
                        'Xbox': ['xbox', 'microsoft xbox'],
                        'Xbox_360': ['xbox 360', 'x360']
                    }

                    # Prüfe, ob Dateiname oder Ordnername auf eine bestimmte Konsole hinweist
                    for potential_console, keywords in console_keywords.items():
                        for keyword in keywords:
                            if keyword in filename_lower or keyword in parent_dir:
                                console = potential_console
                                break
                        if console != 'Unknown':
                            break

                # Wenn keine spezifische Konsole erkannt wurde, verwenden wir die Standard-Zuordnung
                if console == 'Unknown':
                    console = self.CONSOLE_MAP.get(ext, 'Unknown')

                console_counts[console] += 1

            return dict(console_counts)

        # For larger file sets, use parallel processing
        console_counts = Counter()
        file_batches = []
        batch_size = 500

        # Create batches
        for i in range(0, len(files), batch_size):
            file_batches.append(files[i:i+batch_size])

        # Process each batch in parallel
        results = []

        # Define the batch analysis function
        def analyze_batch(batch):
            batch_counts = Counter()
            for file_path in batch:
                try:
                    ext = file_path.suffix.lower()
                    console = self.CONSOLE_MAP.get(ext, 'Unknown')
                    batch_counts[console] += 1

                    # Extract additional metadata if needed
                    if hasattr(self, '_extract_detailed_metadata') and random.random() < 0.01:
                        # Only sample a small percentage of files for detailed analysis
                        self._extract_detailed_metadata(file_path)
                except:
                    # Skip problematic files
                    pass
            return batch_counts

        # Submit all batches for processing
        with concurrent.futures.ThreadPoolExecutor(max_workers=min(4, len(file_batches))) as executor:
            batch_futures = [executor.submit(analyze_batch, batch) for batch in file_batches]

            # Collect results as they complete
            for future in concurrent.futures.as_completed(batch_futures):
                try:
                    batch_result = future.result()
                    console_counts.update(batch_result)
                except Exception as e:
                    print(f"Batch processing error: {e}")

        return dict(console_counts)

    def _extract_detailed_metadata(self, file_path: Path) -> Dict[str, Any]:
        """Extract detailed metadata from file for enhanced console detection."""
        metadata = {'size': 0, 'extension': file_path.suffix.lower()}

        try:
            # Get basic file stats
            stats = os.stat(file_path)
            metadata['size'] = stats.st_size
            metadata['modified'] = datetime.fromtimestamp(stats.st_mtime)
            metadata['created'] = datetime.fromtimestamp(stats.st_ctime)

            # Try to detect file type and header
            if metadata['size'] > 0 and metadata['size'] < 100 * 1024 * 1024:  # < 100MB
                try:
                    # Read first 256 bytes for header analysis
                    with open(file_path, 'rb') as f:
                        header = f.read(256)

                    # Store file signature
                    metadata['signature'] = header[:8].hex()

                    # Basic ROM header detection
                    if metadata['extension'] in ('.nes', '.smc', '.gb', '.gba'):
                        metadata['has_valid_header'] = self._validate_rom_header(
                            metadata['extension'], header)
                except:
                    pass
        except:
            pass

        return metadata

    def _validate_rom_header(self, extension: str, header: bytes) -> bool:
        """Validate ROM file header."""
        # Implement simple header validation for common ROM types
        if extension == '.nes' and header.startswith(b'NES\x1a'):
            return True
        elif extension == '.smc' and len(header) >= 0x10:
            # SNES header check
            return True
        elif extension == '.gb' or extension == '.gbc':
            # Game Boy logo check (partial)
            nintendo_logo_offset = 0x104
            if len(header) >= nintendo_logo_offset + 4:
                return header[nintendo_logo_offset:nintendo_logo_offset+4] == b'\xCE\xED\x66\x66'
        elif extension == '.gba':
            # GBA has Nintendo logo at 0x4
            if len(header) >= 0x4 + 4:
                return header[0xB2:0xB2+4] == b'GAME'

        return False

    def _update_scan_progress(self, file_count: int, scan_state=None):
        """Update scan progress with efficient batching."""
        current_time = time.time()

        # Update UI only every 100ms for better performance
        last_update_time = getattr(self, '_last_progress_update_time', 0)
        if current_time - last_update_time < 0.1 and file_count < 1000:
            return

        self._last_progress_update_time = current_time

        # Update scan state if available
        if scan_state:
            with scan_state['lock']:
                scan_state['total_files'] = max(scan_state['total_files'], file_count)

        # Calculate scan rate for user feedback
        if hasattr(self, '_scan_start_time'):
            elapsed = current_time - self._scan_start_time
            if elapsed > 0:
                files_per_second = int(file_count / elapsed)
                self.root.after(0, self._update_progress_safe, file_count, files_per_second)
        else:
            self._scan_start_time = current_time
            self.root.after(0, self._update_progress_safe, file_count, 0)

    def _update_progress_safe(self, file_count: int, files_per_second: int = 0):
        """Thread-safe progress update with performance metrics."""
        # Scale progress non-linearly for better UX
        if file_count < 100:
            progress = min(30, file_count / 3)
        elif file_count < 1000:
            progress = min(60, 30 + (file_count - 100) / 30)
        else:
            progress = min(80, 60 + (file_count - 1000) / 100)

        # Update progress bar with throttling
        self.progress_bar.update_throttled(progress)

        # Format message based on scan speed
        if files_per_second > 0:
            self.progress_label.configure(text=f"🔍 Found {file_count} files ({files_per_second}/sec)...")
        else:
            self.progress_label.configure(text=f"🔍 Found {file_count} files...")

    def _scan_complete(self, stats: Dict[str, int], total_files: int):
        """Handle scan completion."""
        self.progress_bar.stop_animation()
        self.progress_bar['value'] = 100
        self.progress_label.configure(text=f"✅ Scan complete: {total_files} files found")

        self.stats_widget.update_stats(stats)
        self.log_widget.add_log(f"Scan completed: {total_files} ROM files found", "SUCCESS")

        self._set_running_state(False)

    def _scan_error(self, error_msg: str):
        """Handle scan error."""
        self.progress_bar.stop_animation()
        self.progress_bar['value'] = 0
        self.progress_label.configure(text="❌ Scan failed")

        self.log_widget.add_log(f"Scan error: {error_msg}", "ERROR")
        self._set_running_state(False)

    def _start_sorting(self):
        """Start ROM sorting operation with comprehensive progress tracking."""
        if not self.source_folder.get() or not self.dest_folder.get():
            messagebox.showerror("Error", "Please select both source and destination folders.")
            return

        if self.is_running:
            self.log_widget.add_log("Another operation is running", "WARNING")
            return

    def _cancel_sorting(self):
        """Cancel the ongoing ROM sorting operation."""
        if not self.is_running:
            self.log_widget.add_log("No active sorting operation to cancel", "INFO")
            return

        self.log_widget.add_log("Cancelling sorting operation...", "WARNING")
        self.stop_requested.set()

        # Disable cancel button to prevent multiple clicks
        self.action_button.config(state=tk.DISABLED)
        self.log_widget.add_log("Waiting for current operations to complete...", "INFO")

        # Check source and destination validity
        source_path = Path(self.source_folder.get())
        dest_path = Path(self.dest_folder.get())

        if not source_path.exists() or not source_path.is_dir():
            messagebox.showerror("Error", "Source folder does not exist.")
            return

        if not dest_path.exists():
            # Ask to create destination directory
            if messagebox.askyesno("Create Directory",
                                 f"Destination folder '{dest_path}' does not exist. Create it?"):
                try:
                    os.makedirs(dest_path, exist_ok=True)
                except Exception as e:
                    messagebox.showerror("Error", f"Could not create destination folder: {e}")
                    return
            else:
                return

        # Confirm operation with counts
        file_count = len(self.file_scanner.scan_directory(str(source_path), use_cache=True))
        if file_count == 0:
            messagebox.showwarning("Warning", "No ROM files found in source directory.")
            return

        if not messagebox.askyesno("Confirm",
                                 f"Start sorting {file_count} ROM files?\n\nFrom: {source_path}\nTo: {dest_path}"):
            return

        self._set_running_state(True)
        self.log_widget.add_log(f"Starting ROM sorting of {file_count} files...", "INFO")

        # Create shared state for progress tracking
        sort_state = {
            'total_files': file_count,
            'processed_files': 0,
            'successful_files': 0,
            'failed_files': 0,
            'current_console': '',
            'start_time': time.time(),
            'consoles_processed': set(),
            'lock': threading.RLock()
        }

        # Create stop event for coordinated termination
        stop_event = threading.Event()

        def sort_worker():
            try:
                # Setup progress reporting
                def progress_callback(current_file, total_files, current_console=None):
                    """Callback for tracking progress"""
                    with sort_state['lock']:
                        sort_state['processed_files'] = current_file
                        sort_state['total_files'] = total_files
                        if current_console:
                            sort_state['current_console'] = current_console
                            sort_state['consoles_processed'].add(current_console)

                    # Update UI with progress
                    progress = min(99, int(current_file / total_files * 100)) if total_files else 0
                    self.root.after(0, lambda: self._update_sort_progress(progress, current_console))

                # Error tracking callback
                def error_callback(filename, error_msg):
                    """Callback for error reporting"""
                    with sort_state['lock']:
                        sort_state['failed_files'] += 1

                    self.root.after(0, lambda: self.log_widget.add_log(
                        f"Error processing {os.path.basename(filename)}: {error_msg}", "ERROR"))

                # Success tracking callback
                def success_callback(filename, console):
                    """Callback for successful operations"""
                    with sort_state['lock']:
                        sort_state['successful_files'] += 1

                # Unser eigener optimierter Dateiverarbeitungscode unabhängig von MODULES_AVAILABLE
                try:
                    # Scannen und Organisieren der Dateien direkt in der GUI
                    source_dir = Path(self.source_folder.get())
                    dest_dir = Path(self.dest_folder.get())

                    # Alle ROM-Dateien im Quellverzeichnis sammeln
                    all_files = []
                    for root, dirs, files in os.walk(source_dir):
                        root_path = Path(root)

                        # Für jeden Dateinamen im aktuellen Verzeichnis
                        for filename in files:
                            file_path = root_path / filename
                            ext = file_path.suffix.lower()

                            # Überprüfen, ob es sich um eine unterstützte Dateiendung handelt
                            if ext in self.CONSOLE_MAP:
                                all_files.append(file_path)

                    # Die Gesamtanzahl der Dateien festlegen
                    total_files = len(all_files)
                    with sort_state['lock']:
                        sort_state['total_files'] = total_files

                    # Fortschritt initialisieren
                    current_file = 0

                    # Verarbeiten jeder Datei
                    for file_path in all_files:
                        # Stoppen, wenn erforderlich
                        if stop_event.is_set() or (self.worker_thread and self.worker_thread.should_stop()):
                            break

                        # Verbesserte Konsolentyperkennung aus Dateiendung
                        ext = file_path.suffix.lower()
                        console_type = "Unknown"

                        # Priorisierte Konsolenerkennung basierend auf Dateierweiterung
                        if ext in self.CONSOLE_MAP:
                            console_type = self.CONSOLE_MAP.get(ext)

                        # Verbesserte Konsolenerkennung für generische Dateitypen wie Archive, Binary usw.
                        try:
                            # Erweiterte Erkennung für mehrdeutige Dateierweiterungen (.bin, .iso, .zip, etc.)
                            if console_type in ["Binary", "ROM_File", "Disk_Image", "Archive"]:
                                print(f"Versuche bessere Konsolenerkennung für: {file_path.name}")

                                # 0. Versuche fortgeschrittene Archivdetektion für Archive
                                try:
                                    # Importiere den Archiv-Detektor
                                    from src.detectors.archive_detector import (
                                        is_archive_file, detect_console_from_archive,
                                        improve_generic_type_detection
                                    )

                                    # Verwende den Archiv-Detektor für verbesserte Erkennung
                                    if console_type == "Archive" and is_archive_file(str(file_path)):
                                        detected_console, confidence = detect_console_from_archive(str(file_path))
                                        if detected_console != "Archive" and confidence >= 0.6:
                                            console_type = detected_console
                                            print(f"Archiv-Detektor erkannte Konsole: {console_type} (Konfidenz: {confidence:.2f})")
                                    elif console_type in ["Binary", "ROM_File", "Disk_Image"]:
                                        # Verbessere andere generische Typen
                                        detected_console, confidence = improve_generic_type_detection(
                                            str(file_path), console_type
                                        )
                                        if detected_console != console_type and confidence >= 0.6:
                                            console_type = detected_console
                                            print(f"Verbesserte Erkennung: {console_type} (Konfidenz: {confidence:.2f})")
                                except ImportError:
                                    # Wenn der Archiv-Detektor nicht importiert werden kann
                                    print("Archiv-Detektor nicht verfügbar, verwende Standard-Erkennung")

                                # 1. Versuche CHD-Dateierkennung
                                try:
                                    from src.detectors.chd_detector import (
                                        is_chd_file, detect_console_from_chd
                                    )

                                    # Prüfe, ob es sich um eine CHD-Datei handelt und erkenne die Konsole
                                    if is_chd_file(str(file_path)):
                                        detected_console, confidence = detect_console_from_chd(str(file_path))
                                        if detected_console != "Unknown" and confidence >= 0.6:
                                            console_type = detected_console
                                            print(f"CHD-Detektor erkannte Konsole: {console_type} (Konfidenz: {confidence:.2f})")
                                except ImportError:
                                    # Wenn der CHD-Detektor nicht importiert werden kann
                                    print("CHD-Detektor nicht verfügbar, verwende Standard-Erkennung")

                                # 1. Versuche Erkennung basierend auf Dateinamen (wenn noch generischer Typ)
                                if console_type in ["Binary", "ROM_File", "Disk_Image", "Archive"]:
                                    name_lower = file_path.name.lower()
                                    parent_dir = os.path.basename(os.path.dirname(str(file_path)))

                                    # Versuche Konsolenerkennung aus Verzeichnisnamen
                                    if parent_dir.lower() not in ["roms", "games", "emulation"]:
                                        for console in self.CONSOLE_MAP.values():
                                            if console in ["Binary", "ROM_File", "Disk_Image", "Archive"]:
                                                continue
                                            console_name = console.lower().replace('_', ' ')
                                            if console_name in parent_dir.lower():
                                                console_type = console
                                                print(f"Erkannte Konsole aus Verzeichnisnamen: {console}")
                                                break

                                # Erkenne Konsolen basierend auf erweiterten Dateinamen-Mustern
                                if console_type in ["Binary", "ROM_File", "Disk_Image", "Archive"]:
                                    for known_pattern, console in [
                                        # Nintendo-Systeme
                                        (r'\b(snes|super\s*nintendo|super\s*famicom)\b', 'Super_Nintendo'),
                                        (r'\b(nes|nintendo|famicom)(?!\s*64|\s*ds|\s*3ds)\b', 'Nintendo_NES'),
                                        (r'\b(n64|nintendo\s*64)\b', 'Nintendo_64'),
                                        (r'\b(gc|gamecube|dolphin)\b', 'Nintendo_GameCube'),
                                        (r'\b(wii)(?!\s*u)\b', 'Nintendo_Wii'),
                                        (r'\b(wii\s*u)\b', 'Nintendo_Wii_U'),
                                        (r'\b(switch|nx)\b', 'Nintendo_Switch'),
                                        (r'\b(gameboy(?!\s*advance|\s*color)|game\s*boy(?!\s*advance|\s*color)|dmg)\b', 'Nintendo_Game_Boy'),
                                        (r'\b(gbc|gameboy\s*color|game\s*boy\s*color)\b', 'Nintendo_Game_Boy_Color'),
                                        (r'\b(gba|gameboy\s*advance|game\s*boy\s*advance)\b', 'Nintendo_Game_Boy_Advance'),
                                        (r'\b(nds|nintendo\s*ds)(?!\s*i)\b', 'Nintendo_DS'),
                                        (r'\b(3ds|nintendo\s*3ds|citra)\b', 'Nintendo_3DS'),

                                        # Sony-Systeme
                                        (r'\b(ps1|playstation(?!\s*[2-5])|psx|psone)\b', 'PlayStation'),
                                        (r'\b(ps2|playstation\s*2)\b', 'PlayStation_2'),
                                        (r'\b(ps3|playstation\s*3)\b', 'PlayStation_3'),
                                        (r'\b(ps4|playstation\s*4)\b', 'PlayStation_4'),
                                        (r'\b(psp|playstation\s*portable)\b', 'PlayStation_Portable'),
                                        (r'\b(psvita|ps\s*vita|playstation\s*vita)\b', 'PlayStation_Vita'),

                                        # Sega-Systeme
                                        (r'\b(genesis|mega\s*drive|md)\b', 'Sega_Genesis'),
                                        (r'\b(saturn|sega\s*saturn)\b', 'Sega_Saturn'),
                                        (r'\b(dreamcast|dc)\b', 'Sega_Dreamcast'),
                                        (r'\b(master\s*system|sms)\b', 'Sega_Master_System'),
                                        (r'\b(game\s*gear|gg)\b', 'Sega_Game_Gear'),
                                        (r'\b(32x)\b', 'Sega_32X'),
                                        (r'\b(sega\s*cd|mega\s*cd)\b', 'Sega_CD'),

                                        # Microsoft-Systeme
                                        (r'\b(xbox)(?!\s*360|\s*one)\b', 'Xbox'),
                                        (r'\b(xbox\s*360|x360)\b', 'Xbox_360'),
                                        (r'\b(xbox\s*one|xone)\b', 'Xbox_One'),
                                        (r'\b(xbox\s*series)\b', 'Xbox_Series'),

                                        # Arcade und andere Systeme
                                        (r'\b(arcade|mame|cps1|cps2|cps3)\b', 'MAME_Arcade'),
                                        (r'\b(neo\s*geo|mvs|aes|ngp)\b', 'Neo_Geo'),
                                        (r'\b(atari\s*2600|2600|vcs)\b', 'Atari_2600'),
                                        (r'\b(atari\s*5200|5200)\b', 'Atari_5200'),
                                        (r'\b(atari\s*7800|7800)\b', 'Atari_7800'),
                                        (r'\b(jaguar)\b', 'Atari_Jaguar'),
                                        (r'\b(lynx)\b', 'Atari_Lynx'),
                                        (r'\b(pce|pc\s*engine|tg16|turbo\s*grafx)\b', 'PC_Engine'),
                                        (r'\b(wonderswan|ws)\b', 'WonderSwan'),
                                        (r'\b(coleco|colecovision)\b', 'ColecoVision'),
                                        (r'\b(intellivision|intv)\b', 'Intellivision'),
                                        (r'\b(vectrex)\b', 'Vectrex'),
                                        (r'\b(c64|commodore\s*64)\b', 'Commodore_64'),
                                        (r'\b(amiga)\b', 'Amiga'),
                                        (r'\b(msx)\b', 'MSX'),
                                    ]:
                                        search_text = f"{name_lower} {parent_dir.lower()}"
                                        if re.search(known_pattern, search_text, re.IGNORECASE):
                                            console_type = console
                                            print(f"Erkannte Konsole aus erweitertem Muster: {console}")
                                            break

                                # 2. Versuche utils.detect_console_fast zu verwenden, wenn verfügbar und noch immer generisch
                                if console_type in ["Binary", "ROM_File", "Disk_Image", "Archive"]:
                                    try:
                                        # Verwende den verbesserten Detektionscode für ROMs
                                        from src.utils import detect_console_fast, is_chd_file, detect_console_from_chd, is_archive_file, detect_console_from_archive

                                        # CHD-Datei-Erkennung
                                        if is_chd_file(str(file_path)):
                                            detected_console, confidence = detect_console_from_chd(str(file_path))
                                            if detected_console != "Unknown" and confidence >= 0.6:
                                                console_type = detected_console
                                                print(f"CHD-Datei erkannt: {console_type} (Konfidenz: {confidence:.2f})")
                                        # Archiv-Erkennung
                                        elif is_archive_file(str(file_path)):
                                            detected_console, confidence = detect_console_from_archive(str(file_path))
                                            if detected_console != "Archive" and confidence >= 0.6:
                                                console_type = detected_console
                                                print(f"Archiv-Inhalt erkannt: {console_type} (Konfidenz: {confidence:.2f})")
                                        # Standard ROM-Erkennung
                                        else:
                                            detected, confidence = detect_console_fast(file_path.name, str(file_path))
                                            if detected != "Unknown" and confidence > 0.6:
                                                # Formatiere den Konsolennamen für die Verzeichnisstruktur
                                                console_type = detected.replace(" ", "_")
                                                print(f"Erkannte Konsole mit KI: {console_type} (Konfidenz: {confidence:.2f})")
                                    except (ImportError, ModuleNotFoundError) as e:
                                        # Wenn utils nicht importiert werden kann
                                        print(f"Detektionsmodule nicht verfügbar: {e}")

                                # Fallback: Prüfe Archive auf Inhalt
                                if console_type == "Archive" and ext == '.zip':
                                    try:
                                        import zipfile
                                        console_counts = {}

                                        with zipfile.ZipFile(file_path, 'r') as zip_ref:
                                            file_list = zip_ref.namelist()
                                            # Filtere Verzeichnisse und versteckte Dateien
                                            file_list = [f for f in file_list if not f.endswith('/')
                                                        and not f.startswith('__MACOSX')
                                                        and not f.startswith('.')]

                                            # Prüfe max. 50 Dateien
                                            for zipped_file in file_list[:50]:
                                                zipped_ext = os.path.splitext(zipped_file)[1].lower()
                                                # Überspringe kleine Dateien wie READMEs
                                                if zipped_ext in ['.txt', '.nfo', '.diz', '.md']:
                                                    continue

                                                # Erkenne Konsole aus Datei im Archiv
                                                if zipped_ext in self.CONSOLE_MAP:
                                                    detected_console = self.CONSOLE_MAP.get(zipped_ext)
                                                    # Ignoriere generische Typen
                                                    if detected_console not in ["Binary", "ROM_File", "Disk_Image", "Archive"]:
                                                        console_counts[detected_console] = console_counts.get(detected_console, 0) + 1

                                        # Wenn wir Konsolen gefunden haben, nehmen wir die häufigste
                                        if console_counts:
                                            most_common_console = max(console_counts.items(), key=lambda x: x[1])[0]
                                            console_type = most_common_console
                                            print(f"Erkannte Konsole aus Archivinhalt (verbessert): {console_type}")
                                    except Exception as zip_err:
                                        print(f"Fehler beim Lesen des ZIP-Archivs: {zip_err}")
                        except Exception as detect_err:
                            print(f"Konsolenerkennung fehlgeschlagen: {detect_err}")
                            import traceback
                            traceback.print_exc()

                        # Zielverzeichnis erstellen, falls es nicht existiert
                        console_dir = dest_dir / console_type
                        os.makedirs(console_dir, exist_ok=True)

                        # Zieldateiname bestimmen mit Konfliktbehandlung
                        dest_file = console_dir / file_path.name

                        # Behandlung von Namenskonflikten
                        counter = 1
                        orig_name = file_path.stem
                        while dest_file.exists():
                            # Füge Nummerierung für Duplikate hinzu
                            new_name = f"{orig_name}_{counter}{file_path.suffix}"
                            dest_file = console_dir / new_name
                            counter += 1

                        try:
                            # Tatsächliches Verschieben der Datei mit robuster Fehlerbehandlung
                            try:
                                shutil.move(str(file_path), str(dest_file))
                            except (shutil.Error, PermissionError) as move_error:
                                # Fallback: Wenn Verschieben fehlschlägt, versuche zu kopieren und dann zu löschen
                                print(f"Move fehlgeschlagen, versuche Kopieren: {move_error}")
                                shutil.copy2(str(file_path), str(dest_file))
                                os.unlink(str(file_path))

                            # Erfolgreich verarbeitet
                            with sort_state['lock']:
                                sort_state['successful_files'] += 1
                                sort_state['consoles_processed'].add(console_type)
                                sort_state['current_console'] = console_type

                            # Callback für Protokollierung
                            success_callback(str(file_path), console_type)

                        except Exception as e:
                            # Verbesserte Fehlerbehandlung mit detaillierter Protokollierung
                            error_message = f"{type(e).__name__}: {str(e)}"
                            with sort_state['lock']:
                                sort_state['failed_files'] += 1

                            # Callback für detaillierte Protokollierung
                            error_callback(str(file_path), error_message)

                        # Fortschritt aktualisieren
                        current_file += 1
                        with sort_state['lock']:
                            sort_state['processed_files'] = current_file

                        # Fortschritts-Callback aufrufen
                        progress_callback(current_file, total_files, console_type)

                    # Abschließende Statistiken erstellen
                    result = {
                        'files_processed': current_file,
                        'successful_files': sort_state['successful_files'],
                        'failed_files': sort_state['failed_files'],
                        'duration': time.time() - sort_state['start_time'],
                        'consoles': list(sort_state['consoles_processed'])
                    }

                    # UI aktualisieren
                    self.root.after(0, lambda: self._sort_complete(result, sort_state))

                except Exception as e:
                    # Globale Fehlerbehandlung
                    error_message = f"Sortiervorgang fehlgeschlagen: {str(e)}"
                    self.root.after(0, lambda: self._sort_error(error_message, sort_state))

                else:
                    # Demo mode with realistic simulation
                    total_steps = 100
                    consoles = list(self.CONSOLE_MAP.values())

                    for i in range(total_steps):
                        if stop_event.is_set() or (self.worker_thread and self.worker_thread.should_stop()):
                            break

                        # Simulate processing different consoles
                        if i % 10 == 0 and consoles:
                            console = random.choice(consoles)
                            with sort_state['lock']:
                                sort_state['current_console'] = console
                                sort_state['consoles_processed'].add(console)

                        # Simulate progress
                        with sort_state['lock']:
                            sort_state['processed_files'] = int((i/total_steps) * file_count)
                            sort_state['successful_files'] = int(sort_state['processed_files'] * 0.95)
                            sort_state['failed_files'] = int(sort_state['processed_files'] * 0.05)

                        # Update UI
                        progress = i + 1
                        self.root.after(0, lambda p=progress, c=sort_state['current_console']:
                                        self._update_sort_progress(p, c))

                        # Simulate occasional errors
                        if random.random() < 0.05:
                            self.root.after(0, lambda: self.log_widget.add_log(
                                f"Error processing demo_file_{i}.rom: Simulated error", "ERROR"))

                        # Sleep to simulate work
                        time.sleep(0.05)

                    # Prepare demo result
                    result = {
                        'files_processed': file_count,
                        'successful_files': int(file_count * 0.95),
                        'failed_files': int(file_count * 0.05),
                        'duration': 5.0,
                        'consoles': list(sort_state['consoles_processed'])
                    }

                    with sort_state['lock']:
                        sort_state.update({
                            'duration': time.time() - sort_state['start_time'],
                            'processed_files': file_count,
                            'successful_files': result['successful_files'],
                            'failed_files': result['failed_files']
                        })

                    self.root.after(0, lambda: self._sort_complete(result, sort_state))

            except Exception as e:
                self.root.after(0, lambda: self._sort_error(str(e), sort_state))

        # Create worker thread with cleanup handler
        self.worker_thread = SmartThread(target=sort_worker)
        self.worker_thread.add_cleanup_callback(lambda: stop_event.set())
        self.worker_thread.start()

        # Store stop event for cancellation
        self.worker_thread.stop_event = stop_event

    def _update_sort_progress(self, progress: int, current_console: str = None):
        """Update sorting progress with console information."""
        self.progress_bar.update_throttled(progress)

        # Show more detailed progress information if console is available
        if current_console:
            self.progress_label.configure(text=f"🔄 Sorting {current_console}... {progress}%")
        else:
            self.progress_label.configure(text=f"🔄 Sorting... {progress}%")

    def _sort_complete(self, result: Dict[str, Any], sort_state: Dict[str, Any] = None):
        """Handle sorting completion with comprehensive reporting."""
        self.progress_bar['value'] = 100

        # Get stats from result or state
        files_processed = result.get('files_processed', 0)
        successful_files = result.get('successful_files', 0)
        failed_files = result.get('failed_files', 0)
        duration = result.get('duration', 0)
        consoles = result.get('consoles', [])

        # Get more detailed stats from sort_state if available
        if sort_state:
            files_processed = sort_state.get('processed_files', files_processed)
            successful_files = sort_state.get('successful_files', successful_files)
            failed_files = sort_state.get('failed_files', failed_files)
            duration = time.time() - sort_state.get('start_time', time.time() - duration)
            console_set = sort_state.get('consoles_processed', set())
            if console_set:
                consoles = list(console_set)

        # Calculate rate
        rate = files_processed / max(0.1, duration) if duration > 0 else 0

        # Update UI with completion message
        self.progress_label.configure(text=f"✅ Fertig: {files_processed} Dateien sortiert")

        # Generate detailed report
        report_lines = [
            f"Sortierung abgeschlossen: {files_processed} Dateien in {duration:.1f}s ({rate:.1f} Dateien/Sek)",
            f"• Erfolg: {successful_files} Dateien",
        ]

        # Add failure info if any
        if failed_files > 0:
            report_lines.append(f"• Fehler: {failed_files} Dateien")

        # Add console info if available
        if consoles:
            # Sortiere Konsolen alphabetisch für bessere Lesbarkeit
            consoles_sorted = sorted(consoles)
            # Zeige alle Konsolen an, nicht nur die ersten paar
            console_str = ", ".join(str(c).replace('_', ' ') for c in consoles_sorted)
            report_lines.append(f"• Konsolen: {console_str}")

        # Log completion with detailed report
        self.log_widget.add_log(report_lines[0], "SUCCESS")
        for line in report_lines[1:]:
            self.log_widget.add_log(line, "INFO")

        # Update stats if available
        if hasattr(self, 'stats_widget') and isinstance(self.stats_widget, OptimizedStatsWidget):
            # Sammle tatsächliche Statistiken aus dem Zielordner
            try:
                console_stats = self._collect_actual_statistics()
                if console_stats:
                    self.stats_widget.update_stats(console_stats)
                else:
                    # Fallback zur Schätzung, wenn tatsächliche Statistiken nicht verfügbar sind
                    if consoles:
                        console_stats = {}
                        for console in consoles:
                            # Standardmäßig gleichmäßig aufteilen
                            console_stats[console] = max(1, int(successful_files / len(consoles)))
                        self.stats_widget.update_stats(console_stats)
            except Exception as e:
                print(f"Fehler beim Sammeln der Statistiken: {e}")
                # Bei einem Fehler eine vereinfachte Statistik erstellen
                if consoles:
                    console_stats = {console: 1 for console in consoles}
                    self.stats_widget.update_stats(console_stats)

        # Reset UI state
        self._set_running_state(False)

        # Show completion dialog with report - verbesserte Version mit modaler Anzeige
        self._show_sort_results("Erfolg", report_lines)

    def _show_sort_results(self, title: str, report_lines: List[str]):
        """Verbesserte Methode zum Anzeigen von Ergebnisdialogen mit Modal-Status.
        Verhindert doppelte oder überlappende Erfolgsmeldungen."""
        # Alle vorherigen Toplevel-Fenster schließen, die Erfolg/Error-Dialoge sein könnten
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Toplevel) and widget.wm_title() in ["Erfolg", "Error"]:
                try:
                    widget.destroy()
                except:
                    pass

        # Neuen Dialog erstellen und als modal konfigurieren
        dialog = tk.Toplevel(self.root)
        dialog.title(title)
        dialog.transient(self.root)  # Dialog an Hauptfenster binden
        dialog.grab_set()  # Modal machen
        dialog.resizable(False, False)

        # Icon für Erfolg
        icon_label = tk.Label(dialog, text="✅", font=("Segoe UI", 24))
        icon_label.pack(pady=(15, 5))

        # Hauptnachricht
        msg_frame = tk.Frame(dialog)
        msg_frame.pack(fill="both", expand=True, padx=20, pady=10)

        msg_text = tk.Text(msg_frame, wrap="word", height=10, width=50)
        msg_text.pack(fill="both", expand=True)
        msg_text.insert("1.0", "\n".join(report_lines))
        msg_text.config(state="disabled")

        # OK-Button
        btn = tk.Button(dialog, text="OK", width=10, command=dialog.destroy)
        btn.pack(pady=(5, 15))

        # Zentriere Dialog
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        # Focus auf OK-Button
        btn.focus_set()

    def _collect_actual_statistics(self) -> Dict[str, int]:
        """Sammelt tatsächliche Statistiken aus dem Zielordner."""
        try:
            dest_dir = Path(self.dest_folder.get())
            if not dest_dir.exists() or not dest_dir.is_dir():
                return {}

            stats = {}

            # Durchlaufe alle Unterverzeichnisse im Zielordner
            for item in dest_dir.iterdir():
                if item.is_dir():
                    # Zähle alle Dateien im Konsolenverzeichnis
                    console_name = item.name
                    file_count = 0

                    # Zähle alle Dateien mit unterstützten Erweiterungen
                    for ext in self.CONSOLE_MAP.keys():
                        # Normalisiere die Erweiterung
                        ext_norm = ext.lower()
                        if not ext_norm.startswith('.'):
                            ext_norm = f".{ext_norm}"

                        # Zähle Dateien mit dieser Erweiterung
                        file_count += len(list(item.glob(f"*{ext_norm}")))

                    # Füge zur Statistik hinzu, wenn Dateien gefunden wurden
                    if file_count > 0:
                        stats[console_name] = file_count

            return stats
        except Exception as e:
            print(f"Fehler beim Sammeln der Statistiken: {e}")
            import traceback
            traceback.print_exc()
            return {}

    def _sort_error(self, error_msg: str, sort_state: Dict[str, Any] = None):
        """Handle sorting error with partial progress reporting."""
        self.progress_bar['value'] = 0
        self.progress_label.configure(text="❌ Sorting failed")

        # Log the error
        self.log_widget.add_log(f"Sorting error: {error_msg}", "ERROR")

        # Show partial progress if available
        if sort_state:
            processed = sort_state.get('processed_files', 0)
            total = sort_state.get('total_files', 0)
            if processed > 0 and total > 0:
                progress_pct = (processed / total * 100) if total > 0 else 0
                self.log_widget.add_log(
                    f"Partial progress: {processed}/{total} files ({progress_pct:.1f}%)",
                    "WARNING"
                )

                # Add info about successfully processed files
                successful = sort_state.get('successful_files', 0)
                if successful > 0:
                    self.log_widget.add_log(
                        f"Successfully processed: {successful} files before error",
                        "INFO"
                    )

        # Reset UI state
        self._set_running_state(False)

        # Erstelle Fehlermeldungstext
        error_lines = [f"Sortierung fehlgeschlagen: {error_msg}"]

        # Füge Details hinzu, wenn verfügbar
        if sort_state and sort_state.get('processed_files', 0) > 0:
            error_lines.append("")
            error_lines.append(f"Teilweiser Fortschritt: {sort_state['processed_files']} Dateien wurden vor dem Fehler verarbeitet.")

        # Verwende die verbesserte Methode zum Anzeigen der Fehlermeldung
        self._show_error_dialog("Fehler", error_lines)

    def _show_error_dialog(self, title: str, error_lines: List[str]):
        """Verbesserte Methode zum Anzeigen von Fehlerdialogen mit Modal-Status.
        Verhindert doppelte oder überlappende Fehlermeldungen."""
        # Alle vorherigen Toplevel-Fenster schließen, die Erfolg/Error-Dialoge sein könnten
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Toplevel) and widget.wm_title() in ["Erfolg", "Error", "Fehler"]:
                try:
                    widget.destroy()
                except:
                    pass

        # Neuen Dialog erstellen und als modal konfigurieren
        dialog = tk.Toplevel(self.root)
        dialog.title(title)
        dialog.transient(self.root)  # Dialog an Hauptfenster binden
        dialog.grab_set()  # Modal machen
        dialog.resizable(False, False)

        # Icon für Fehler
        icon_label = tk.Label(dialog, text="❌", font=("Segoe UI", 24), fg="red")
        icon_label.pack(pady=(15, 5))

        # Hauptnachricht
        msg_frame = tk.Frame(dialog)
        msg_frame.pack(fill="both", expand=True, padx=20, pady=10)

        msg_text = tk.Text(msg_frame, wrap="word", height=8, width=50)
        msg_text.pack(fill="both", expand=True)
        msg_text.insert("1.0", "\n".join(error_lines))
        msg_text.config(state="disabled")

        # OK-Button
        btn = tk.Button(dialog, text="OK", width=10, command=dialog.destroy)
        btn.pack(pady=(5, 15))

        # Zentriere Dialog
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        # Focus auf OK-Button
        btn.focus_set()

    def _stop_operation(self):
        """Stop current operation with proper resource cleanup."""
        if not self.is_running:
            return

        self.progress_label.configure(text="⏹️ Stopping operation...")
        self.log_widget.add_log("Stopping operation...", "WARNING")

        # Cancel all operations
        try:
            # Signal stop to worker thread
            if self.worker_thread and self.worker_thread.is_alive():
                self.worker_thread.stop()

            # Set shutdown flag
            self._shutdown_requested.set()

            # Cancel any pending tasks in the thread pool
            with self._workers_lock:
                for worker in self._active_workers:
                    if worker.is_alive():
                        worker.stop()

            # Reset UI state after short delay to allow cleanup
            self.root.after(200, self._set_running_state, False)

            self.log_widget.add_log("Operation stopped", "WARNING")

        except Exception as e:
            self.log_widget.add_log(f"Error stopping operation: {e}", "ERROR")
            # Always reset state in case of error
            self._set_running_state(False)
            if self.worker_thread:
                self.worker_thread.stop()

                # Set additional stop events if available
                if hasattr(self.worker_thread, 'stop_event'):
                    self.worker_thread.stop_event.set()

                # For operations with scanner
                if hasattr(self.file_scanner, '_stop_event') and self.file_scanner._stop_event:
                    self.file_scanner._stop_event.set()

            # Cancel any pending after calls
            try:
                for after_id in self.root.tk.call('after', 'info'):
                    try:
                        self.root.after_cancel(after_id)
                    except:
                        pass
            except:
                pass

            # Signal shutdown to any other components
            if hasattr(self, '_shutdown_requested'):
                self._shutdown_requested.set()

            # Update UI after a short delay to allow worker threads to respond to stop signal
            self.root.after(100, self._confirm_operation_stopped)
        except Exception as e:
            # If anything fails, force stop
            print(f"Error stopping operation: {e}")
            self._set_running_state(False)
            self.log_widget.add_log(f"Error while stopping: {e}", "ERROR")

    def _confirm_operation_stopped(self):
        """Confirm operation has stopped and update UI."""
        # Log the stop
        self.log_widget.add_log("Operation stopped by user", "WARNING")

        # Check if thread has actually stopped
        if self.worker_thread and self.worker_thread.is_alive():
            # Thread still running, wait a bit longer
            self.root.after(300, self._force_operation_stopped)
        else:
            # Thread stopped successfully
            self._set_running_state(False)
            self.progress_bar['value'] = 0
            self.progress_label.configure(text="Operation stopped")

    def _force_operation_stopped(self):
        """Force operation to stop if graceful stop failed."""
        # Final check
        if self.worker_thread and self.worker_thread.is_alive():
            self.log_widget.add_log("Force stopping unresponsive operation", "WARNING")
            # We've tried our best, just reset the UI

        # Reset UI state regardless
        self._set_running_state(False)
        self.progress_bar['value'] = 0
        self.progress_label.configure(text="Operation stopped")

    def _close_all_dialogs(self):
        """Schließt alle aktiven Dialog-Fenster."""
        try:
            # Schließe alle Toplevel-Dialoge, die als Erfolgs- oder Fehlermeldungen dienen könnten
            for widget in self.root.winfo_children():
                if isinstance(widget, tk.Toplevel) and widget.wm_title() in ["Erfolg", "Error", "Fehler"]:
                    try:
                        widget.destroy()
                    except:
                        pass
        except Exception as e:
            print(f"Fehler beim Schließen von Dialogen: {e}")

    def _set_running_state(self, running: bool):
        """Set running state and update UI."""
        self.is_running = running

        # Schließe alle bestehenden Dialoge beim Starten einer Operation
        if running:
            self._close_all_dialogs()

            # Disable input elements - use correct widget names
            widgets_to_disable = [self.scan_btn, self.start_btn]

            # Add checkbutton if available
            try:
                # Find the console mode checkbutton in the options frame
                for child in self.root.winfo_children():
                    if hasattr(child, 'winfo_children'):
                        for subchild in child.winfo_children():
                            if hasattr(subchild, 'winfo_children'):
                                for widget in subchild.winfo_children():
                                    if isinstance(widget, tk.Checkbutton):
                                        widgets_to_disable.append(widget)
            except:
                pass

            for widget in widgets_to_disable:
                try:
                    widget.configure(state='disabled')
                except:
                    pass

            # Enable stop button
            self.stop_btn.configure(state='normal')

        else:
            # Re-enable input elements
            try:
                self.scan_btn.configure(state='normal')
                self.start_btn.configure(state='normal')

                # Reset progress bar
                self.progress_bar.stop_animation()
                self.progress_bar['value'] = 0

                # Update labels
                self.progress_label.configure(text="Ready")

                # Disable stop button
                self.stop_btn.configure(state='disabled')

                # Re-enable all checkbuttons
                for child in self.root.winfo_children():
                    if hasattr(child, 'winfo_children'):
                        for subchild in child.winfo_children():
                            if hasattr(subchild, 'winfo_children'):
                                for widget in subchild.winfo_children():
                                    if isinstance(widget, tk.Checkbutton):
                                        widget.configure(state='normal')
            except Exception as e:
                # Log error but don't crash
                print(f"Error resetting UI state: {e}")
            # Enable input elements - use correct widget names
            widgets_to_enable = [self.scan_btn, self.start_btn]

            # Add checkbutton if available
            try:
                for child in self.root.winfo_children():
                    if hasattr(child, 'winfo_children'):
                        for subchild in child.winfo_children():
                            if hasattr(subchild, 'winfo_children'):
                                for widget in subchild.winfo_children():
                                    if isinstance(widget, tk.Checkbutton):
                                        widgets_to_enable.append(widget)
            except:
                pass

            for widget in widgets_to_enable:
                try:
                    widget.configure(state='normal')
                except:
                    pass

            # Disable stop button
            self.stop_btn.configure(state='disabled')

            # Stop progress bar animation
            self.progress_bar.stop_animation()

    def _show_help(self):
        """Show help dialog."""
        help_text = """ROM Sorter Pro v2.1.4 - Help

Quick Start:
1. Select source folder containing ROM files
2. Select destination folder for organized ROMs
3. Click 'Preview Scan' to see what will be sorted
4. Click 'Start Sorting' to organize your ROMs

Supported Formats:
• Nintendo: .nes, .smc, .sfc, .n64, .z64, .gb, .gbc, .gba
• PlayStation: .iso, .bin, .cue, .pbp
• Archives: .zip, .7z, .rar
• And many more!

Features:
• Automatic console detection
• Duplicate handling
• Progress tracking
• Safe file operations"""

        messagebox.showinfo("Help", help_text)

    def _on_closing(self):
        """Handle window closing."""
        if self.is_running:
            if messagebox.askyesno("Confirm", "An operation is running. Stop and exit?"):
                self._stop_operation()
                self.root.after(100, self._cleanup_and_exit)
        else:
            self._cleanup_and_exit()

    def _cleanup_and_exit(self):
        """Cleanup and exit."""
        self._cleanup_all()
        self.root.destroy()

    def _cleanup_all(self):
        """Comprehensive cleanup of all resources."""
        try:
            # Signal shutdown to all components
            if hasattr(self, '_shutdown_requested'):
                self._shutdown_requested.set()

            # Log cleanup start
            print("Starting application cleanup...")

            # Stop worker thread with timeout
            if self.worker_thread:
                try:
                    self.worker_thread.stop()
                    # Set additional stop events if available
                    if hasattr(self.worker_thread, 'stop_event'):
                        self.worker_thread.stop_event.set()
                    # Wait for thread to terminate with timeout
                    self.worker_thread.join(timeout=0.5)
                except Exception as e:
                    print(f"Worker thread cleanup error: {e}")

            # Cancel any pending after() calls
            try:
                for after_id in self.root.tk.call('after', 'info'):
                    try:
                        self.root.after_cancel(after_id)
                    except:
                        pass
            except:
                pass

            # Shutdown thread pool with proper cleanup
            if hasattr(self, 'thread_pool'):
                try:
                    print("Shutting down thread pool...")
                    # Cancel pending tasks and wait for active ones
                    self.thread_pool.shutdown(wait=True, cancel_futures=True)
                except Exception as e:
                    print(f"Thread pool shutdown error: {e}")

            # Run cleanup callbacks in reverse order (LIFO for dependencies)
            for callback in reversed(self._cleanup_callbacks):
                try:
                    callback()
                except Exception as e:
                    print(f"Cleanup callback error: {e}")

            # Clear all circular references
            self._cleanup_callbacks = []
            self.log_widget = None
            self.stats_widget = None
            self.progress_bar = None
            self.file_scanner = None

            # Force garbage collection with generations
            print("Running garbage collection...")
            gc.collect(0)  # Young generation
            gc.collect(1)  # Intermediate generation
            gc.collect(2)  # Old generation

            print("Application cleanup completed")

        except Exception as e:
            print(f"Cleanup error: {e}")

    def run(self):
        """Run the GUI application."""
        try:
            self.log_widget.add_log("ROM Sorter Pro v2.1.4 initialized", "INFO")
            self.root.mainloop()
        except KeyboardInterrupt:
            self._cleanup_and_exit()
        except Exception as e:
            print(f"Application error: {e}")
            self._cleanup_and_exit()

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

# Integriere die Datenbank-Funktionalität in die GUI-Klasse
try:
    from src.database.db_gui_integration import add_database_methods_to_gui
    OptimizedROMSorterGUI = add_database_methods_to_gui(OptimizedROMSorterGUI)
except Exception as e:
    print(f"Warnung: Datenbank-Integration konnte nicht geladen werden: {e}")

    # Wenn die Datenbank-Integration nicht geladen werden kann, implementiere die fehlenden Methoden
    def _display_database_status(self):
        """Fallback-Implementierung für die Anzeige des Datenbankstatus."""
        self.status_bar.config(text="Datenbankstatus: Datenbank nicht verfügbar")

    def _show_database_manager(self):
        """Fallback-Implementierung für den Datenbank-Manager."""
        messagebox.showinfo("Datenbank-Manager", "Die Datenbank-Funktionen sind nicht verfügbar.")

    def _show_database_docs(self):
        """Fallback-Implementierung für die Dokumentation."""
        messagebox.showinfo("Dokumentation", "Die Datenbank-Dokumentation ist nicht verfügbar.")

    # Füge die Fallback-Methoden zur Klasse hinzu
    OptimizedROMSorterGUI._display_database_status = _display_database_status
    OptimizedROMSorterGUI._show_database_manager = _show_database_manager
    OptimizedROMSorterGUI._show_database_docs = _show_database_docs

# Füge die fehlende Methode _open_log_file direkt zur GUI-Klasse hinzu
def _open_log_file(self):
    """Öffnet die aktuelle Log-Datei."""
    try:
        # Gehe vom UI-Verzeichnis ein Verzeichnis nach oben für die logs
        ui_dir = os.path.dirname(os.path.abspath(__file__))
        app_dir = os.path.dirname(ui_dir)
        log_path = os.path.join(app_dir, 'logs')

        # Finde die neueste Log-Datei
        if os.path.exists(log_path):
            log_files = [f for f in os.listdir(log_path) if f.startswith('rom_sorter_')]
            if log_files:
                log_files.sort(reverse=True)  # Neueste zuerst
                latest_log = os.path.join(log_path, log_files[0])

                # Öffne die Log-Datei
                if platform.system() == 'Windows':
                    os.startfile(latest_log)
                elif platform.system() == 'Darwin':  # macOS
                    os.system(f'open "{latest_log}"')
                else:  # Linux und andere
                    os.system(f'xdg-open "{latest_log}"')
                return

        messagebox.showinfo("Info", "Keine Log-Datei gefunden.")
    except Exception as e:
        messagebox.showerror("Fehler", f"Fehler beim Öffnen der Log-Datei: {e}")

# Füge die Methode nachträglich zur Klasse hinzu
OptimizedROMSorterGUI._open_log_file = _open_log_file

def launch_gui():
    """Launch GUI interface for ROM Sorter."""
    try:
        app = OptimizedROMSorterGUI()
        app.run()
    except Exception as e:
        print(f"Failed to start GUI: {e}")
        sys.exit(1)

def main():
    """Main entry point."""
    try:
        app = OptimizedROMSorterGUI()
        app.run()
    except Exception as e:
        print(f"Failed to start GUI: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

# ============================================================================
# END OF OPTIMIZED GUI MODULE
# ============================================================================
