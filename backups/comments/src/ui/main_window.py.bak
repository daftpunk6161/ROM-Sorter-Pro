#!/usr/bin/env python3
# -*-coding: utf-8-*-
"""
ROM Sorter Pro - Main Window v2.1.8
"""

# Standard-Bibliotheken
import logging
import queue
import threading
import os
import time
import glob
import random
import platform
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable, Union, Tuple

# GUI-Bibliotheken
import tkinter as tk
from tkinter import ttk, messagebox, filedialog

# Relative Imports
from .base import STYLE, BaseApp, center_window

class ROMSorterWindow(tk.Tk):
    """Main window of the ROM Sorter application."""

    def __init__(self):
        """Initialize the main window."""
        super().__init__()
        self.title("ROM Sorter Pro ðŸŽ® - v2.1.8")
        self.geometry("1000x700")
        self.minsize(800, 600)

        # Improve the rendering performance
        self.tk.call('package', 'forget', 'Tk_syncLed')
        self.tk.call('tk', 'useinputmethods', '1')
        self.tk.call('tk', 'scaling', '1.0')  # Consistent scaling

        # Center the window
        center_window(self, 1000, 700)

        # Initialize variables
        self._initialize_variables()

        # Create UI components
        self._create_menu()
        self._create_layout()

        # Initialize worker threads
        self._initialize_workers()

        # Record the creation of the window
        logging.info("ROM Sorter main window created")

        # Handle window close event
        self.protocol("WM_DELETE_WINDOW", self._on_close)

    def _initialize_variables(self):
        """Initialize variables for the application."""
        # Path variables
        self.source_path = tk.StringVar()
        self.dest_path = tk.StringVar()

        # Status variables
        self.status_text = tk.StringVar(value="Ready")
        self.progress_value = tk.DoubleVar(value=0.0)
        self.is_processing = threading.Event()

        # Option variables
        self.copy_mode = tk.BooleanVar(value=True)  # True = Copy, False = Move
        self.recursive_scan = tk.BooleanVar(value=True)
        self.create_subfolders = tk.BooleanVar(value=True)
        self.overwrite_existing = tk.BooleanVar(value=False)

        # Progress values
        self.total_files = 0
        self.processed_files = 0

        # Queue for thread communication
        self.message_queue = queue.Queue()

    def _create_menu(self):
        """Create the menu bar."""
        menubar = tk.Menu(self)

        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="Select Source Folder...", command=lambda: self._select_folder("source"))
        file_menu.add_command(label="Select Destination Folder...", command=lambda: self._select_folder("dest"))
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self._on_close)
        menubar.add_cascade(label="File", menu=file_menu)

        # Actions menu
        action_menu = tk.Menu(menubar, tearoff=0)
        action_menu.add_command(label="Sort ROMs", command=self._on_start_sorting)
        action_menu.add_command(label="Cancel", command=self._on_cancel_sorting)
        action_menu.add_separator()
        action_menu.add_command(label="Open Log File", command=self.open_log_file)
        menubar.add_cascade(label="Actions", menu=action_menu)

        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="Documentation", command=self._show_documentation)
        help_menu.add_command(label="About ROM Sorter", command=self._show_about)
        menubar.add_cascade(label="Help", menu=help_menu)

        # Use menu bars
        self.config(menu=menubar)

    def _create_layout(self):
        """Create the main layout of the application."""
        # Main frame with padding
        main_frame = tk.Frame(self, bg=STYLE.colors.bg_primary)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Upper area (Header)
        self._create_header(main_frame)

        # Mittlerer Bereich (Zweispaltig)
        content_frame = tk.Frame(main_frame, bg=STYLE.colors.bg_primary)
        content_frame.pack(fill='both', expand=True, padx=5, pady=5)

        # Linke Spalte
        left_frame = tk.Frame(content_frame, bg=STYLE.colors.bg_primary, width=300)
        left_frame.pack(side='left', fill='y', padx=5, pady=5)
        left_frame.pack_propagate(False)  # Prevents the frame from shrinking

        # Rechte Spalte
        right_frame = tk.Frame(content_frame, bg=STYLE.colors.bg_primary)
        right_frame.pack(side='left', fill='both', expand=True, padx=5, pady=5)

        # Create the panel content
        self._create_left_panel(left_frame)
        self._create_right_panel(right_frame)

        # Unterer Bereich (Footer)
        self._create_footer(main_frame)

    def _create_header(self, parent):
        """Erstelle den Header-Bereich."""
        header_frame = tk.Frame(parent, bg=STYLE.colors.accent_primary, height=60)
        header_frame.pack(fill='x', pady=(0, 10))
        header_frame.pack_propagate(False)  # Prevents the frame from shrinking

        # Logo and title
        title_label = tk.Label(
            header_frame,
            text="ROM Sorter Pro",
            font=STYLE.fonts.title,
            bg=STYLE.colors.accent_primary,
            fg="#ffffff"
        )
        title_label.pack(side='left', padx=20, pady=10)

        # Version and info
        version_label = tk.Label(
            header_frame,
            text="v2.1.8",
            font=STYLE.fonts.small,
            bg=STYLE.colors.accent_primary,
            fg="#ffffff"
        )
        version_label.pack(side='right', padx=20, pady=10)

    def _create_left_panel(self, parent):
        """Create the left panel with folder selection and options."""
        # Select source folder
        source_frame = tk.LabelFrame(parent, text="Quellordner", bg=STYLE.colors.bg_primary)
        source_frame.pack(fill='x', padx=5, pady=5)

        source_entry = tk.Entry(source_frame, textvariable=self.source_path)
        source_entry.pack(side='left', fill='x', expand=True, padx=5, pady=5)

        source_button = tk.Button(
            source_frame,
            text="Durchsuchen",
            command=lambda: self._select_folder("source")
        )
        source_button.pack(side='right', padx=5, pady=5)

        # Select target folder
        dest_frame = tk.LabelFrame(parent, text="Zielordner", bg=STYLE.colors.bg_primary)
        dest_frame.pack(fill='x', padx=5, pady=5)

        dest_entry = tk.Entry(dest_frame, textvariable=self.dest_path)
        dest_entry.pack(side='left', fill='x', expand=True, padx=5, pady=5)

        dest_button = tk.Button(
            dest_frame,
            text="Durchsuchen",
            command=lambda: self._select_folder("dest")
        )
        dest_button.pack(side='right', padx=5, pady=5)

        # Optionen
        options_frame = tk.LabelFrame(parent, text="Optionen", bg=STYLE.colors.bg_primary)
        options_frame.pack(fill='x', padx=5, pady=5)

        # Add options
        options = [
            ("Kopieren statt verschieben", self.copy_mode),
            ("Unterordner durchsuchen", self.recursive_scan),
            ("Unterordner pro Konsole erstellen", self.create_subfolders),
            ("Bestehende Dateien Ã¼berschreiben", self.overwrite_existing)
        ]

        for text, var in options:
            cb = tk.Checkbutton(
                options_frame,
                text=text,
                variable=var,
                bg=STYLE.colors.bg_primary
            )
            cb.pack(anchor='w', padx=5, pady=2)

        # Start-Button
        start_button = tk.Button(
            parent,
            text="ROMs sortieren",
            command=self._on_start_sorting,
            bg=STYLE.colors.accent_secondary,
            fg="white",
            font=STYLE.fonts.button
        )
        start_button.pack(fill='x', padx=5, pady=10)

    def _create_right_panel(self, parent):
        """Create the right panel with tabs for statistics and logs."""
        # Create notebook for tabs
        notebook = ttk.Notebook(parent)
        notebook.pack(fill='both', expand=True)

        # Tab by file list
        files_frame = tk.Frame(notebook, bg=STYLE.colors.bg_primary)
        notebook.add(files_frame, text="Dateien")

        # Simple list box for files
        file_list = tk.Listbox(
            files_frame,
            bg="white",
            selectbackground=STYLE.colors.accent_primary,
            selectforeground="white",
            height=20
        )
        file_list.pack(fill='both', expand=True, padx=5, pady=5)

        # Scroll bar for the list box
        scrollbar = tk.Scrollbar(file_list)
        scrollbar.pack(side='right', fill='y')

        file_list.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=file_list.yview)

        self.file_list = file_list  # Save reference

        # Tab for logs
        log_frame = tk.Frame(notebook, bg=STYLE.colors.bg_primary)
        notebook.add(log_frame, text="Logs")

        # Text widget for logs
        log_text = tk.Text(
            log_frame,
            bg="white",
            height=20,
            wrap=tk.WORD
        )
        log_text.pack(fill='both', expand=True, padx=5, pady=5)

        # Scroll bar for the text widget
        log_scrollbar = tk.Scrollbar(log_text)
        log_scrollbar.pack(side='right', fill='y')

        log_text.config(yscrollcommand=log_scrollbar.set)
        log_scrollbar.config(command=log_text.yview)

        self.log_text = log_text  # Save reference

    def _create_footer(self, parent):
        """Create the footer area with status display and progress bar."""
        footer_frame = tk.Frame(parent, bg=STYLE.colors.bg_secondary, height=40)
        footer_frame.pack(fill='x', pady=(10, 0))
        footer_frame.pack_propagate(False)  # Prevents the frame from shrinking

        # Statusanzeige
        status_label = tk.Label(
            footer_frame,
            textvariable=self.status_text,
            font=STYLE.fonts.default,
            bg=STYLE.colors.bg_secondary,
            anchor='w'
        )
        status_label.pack(side='left', padx=10, pady=5, fill='x', expand=True)

        # Fortschrittsbalken
        progress_bar = ttk.Progressbar(
            footer_frame,
            variable=self.progress_value,
            orient='horizontal',
            mode='determinate',
            length=200
        )
        progress_bar.pack(side='right', padx=10, pady=5)

    def _initialize_workers(self):
        """Initialize worker threads for background tasks."""
        # Thread for the processing of UI updates
        self.update_thread = threading.Thread(
            target=self._process_message_queue,
            daemon=True,
            name="UI-Update-Thread"
        )
        self.update_thread.start()

    def _process_message_queue(self):
        """Process messages from the queue for UI updates."""
        while True:
            try:
                # Get the next message out of the queue
                message = self.message_queue.get(timeout=0.1)

                # Process different message types
                if isinstance(message, dict):
                    action = message.get("action", "")

                    # Log message
                    if action == "log" and "text" in message:
                        self.log_text.insert(tk.END, message["text"])
                        self.log_text.see(tk.END)

                    # Progress update
                    elif action == "progress_update":
                        if "value" in message:
                            self.progress_value.set(message["value"])
                        if "status" in message:
                            self.status_text.set(message["status"])
                        if "log" in message:
                            self.log_text.insert(tk.END, message["log"])
                            self.log_text.see(tk.END)

                    # Completion message
                    elif action == "complete":
                        if "status" in message:
                            self.status_text.set(message["status"])
                        if "log" in message:
                            self.log_text.insert(tk.END, message["log"])
                            self.log_text.see(tk.END)

                # Mark as done
                self.message_queue.task_done()

            except queue.Empty:
                # No message in queue, just continue
                pass
            except Exception as e:
                logging.error(f"Error processing message: {e}")

            # Check if the window still exists, if not, break the loop
            try:
                self.winfo_exists()
            except tk.TclError:
                break

    def _select_folder(self, target):
        """Open dialog to select a folder."""
        folder = filedialog.askdirectory(title=f"Bitte wÃ¤hlen Sie einen {'Quell' if target == 'source' else 'Ziel'}-Ordner")

        if folder:
            if target == "source":
                self.source_path.set(folder)
                self.status_text.set(f"Quellordner gesetzt: {folder}")
            else:
                self.dest_path.set(folder)
                self.status_text.set(f"Zielordner gesetzt: {folder}")

    def _on_start_sorting(self):
        """Starte den Sortierprozess."""
        source = self.source_path.get()
        dest = self.dest_path.get()

        if not source or not os.path.isdir(source):
            messagebox.showerror("Fehler", "Bitte wÃ¤hlen Sie einen gÃ¼ltigen Quellordner.")
            return

        if not dest or not os.path.isdir(dest):
            messagebox.showerror("Fehler", "Bitte wÃ¤hlen Sie einen gÃ¼ltigen Zielordner.")
            return

        # Clear file list
        self.file_list.delete(0, tk.END)

        # Add dummy files for demonstration
        files = glob.glob(os.path.join(source, "**/*.*"), recursive=self.recursive_scan.get())
        rom_extensions = [".gb", ".gbc", ".gba", ".nes", ".snes", ".n64", ".z64", ".v64", ".smd", ".bin", ".iso", ".cue"]

        # Filter to show only ROMs by common extensions (simple demo)
        rom_files = [f for f in files if any(f.lower().endswith(ext) for ext in rom_extensions)]

        for file in rom_files[:100]:  # Limit to 100 files for performance
            self.file_list.insert(tk.END, os.path.basename(file))

        # Update UI
        self.is_processing.set()
        self.status_text.set("Sortiere ROMs...")
        self.progress_value.set(0)

        # Mock progress for demonstration
        self.total_files = len(rom_files)

        # Start a background thread to simulate sorting
        threading.Thread(
            target=self._simulate_sorting,
            args=(source, dest, rom_files),
            daemon=True,
            name="Sorting-Thread"
        ).start()

    def _simulate_sorting(self, source, dest, files):
        """Simulate the sorting process for demonstration."""
        self.processed_files = 0

        # Add to log
        self.message_queue.put({
            "action": "log",
            "text": f"Starte Sortierung von {len(files)} Dateien...\n"
        })

        # Process each file
        for i, file in enumerate(files):
            # Simulate processing time
            time.sleep(0.05)

            # Get a random console for demo
            consoles = ["NES", "SNES", "GameBoy", "GameBoyColor", "GameBoyAdvance",
                        "N64", "MasterSystem", "Genesis", "PlayStation"]
            console = random.choice(consoles)

            # Update progress
            self.processed_files = i + 1

            # Update UI via queue
            self.message_queue.put({
                "action": "progress_update",
                "value": (i + 1) / len(files) * 100,
                "status": f"Verarbeite: {os.path.basename(file)}",
                "log": f"Erkannt als {console}: {os.path.basename(file)}\n"
            })

        # Complete
        self.message_queue.put({
            "action": "complete",
            "status": f"Fertig! {self.processed_files} ROMs sortiert.",
            "log": f"\nSortierung abgeschlossen. {self.processed_files} ROMs wurden sortiert.\n"
        })
        self.is_processing.clear()

    def _on_cancel_sorting(self):
        """Sortierungsprozess abbrechen."""
        if self.is_processing.is_set():
            self.is_processing.clear()
            self.status_text.set("Sortierung abgebrochen")
            self.message_queue.put({
                "action": "log",
                "text": "Sortierung wurde vom Benutzer abgebrochen.\n"
            })

    def _show_documentation(self):
        """Show the documentation."""
        messagebox.showinfo("Dokumentation",
                           "Die Dokumentation fÃ¼r ROM Sorter Pro finden Sie im 'docs' Ordner.")

    def _show_about(self):
        """Show information about the application."""
        messagebox.showinfo("Ãœber ROM Sorter Pro",
                           "ROM Sorter Pro v2.1.8\n\n"
                           "Ein universeller Organizer fÃ¼r ROM-Dateien.\n\n"
                           "Â© 2025")

    def open_log_file(self):
        """Opens the current log file."""
        try:
            # Go up to the logs from the UI Directory
            ui_dir = os.path.dirname(os.path.abspath(__file__))
            app_dir = os.path.dirname(ui_dir)
            log_path = os.path.join(app_dir, 'logs')

            # Find the latest log file
            if os.path.exists(log_path):
                log_files = [f for f in os.listdir(log_path) if f.startswith('rom_sorter_')]
                if log_files:
                    log_files.sort(reverse=True)  # Neueste zuerst
                    latest_log = os.path.join(log_path, log_files[0])

                    # Open the log file
                    if platform.system() == 'Windows':
                        os.startfile(latest_log)
                    elif platform.system() == 'Darwin':  # macOS
                        os.system(f'open "{latest_log}"')
                    else:  # Linux and others
                        os.system(f'xdg-open "{latest_log}"')
                    return

            messagebox.showinfo("Info", "Keine Log-Datei gefunden.")
        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Ã–ffnen der Log-Datei: {e}")

    def _on_close(self):
        """Handle window close event."""
        # Cancel any running operations
        self.is_processing.clear()

        # Destroy the window
        self.destroy()


if __name__ == "__main__":
    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # Start the application
    app = ROMSorterWindow()
    app.mainloop()
