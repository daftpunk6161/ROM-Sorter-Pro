#!/usr/bin/env python3
# -*-coding: utf-8-*-

"""ROM SARTER PRO-AI-based ROM recognition This module implements a AI-based ROM recognition function, the patterns identified in Rome header and file names to the console platform more precisely to determine. The system uses a combination of rule -based heuristics and simple classification algorithms to do without external ML libraries to function. Features: - Header-based signature detection with weighted similarity analysis - Self -learning system that learns from user feedback - Local feature caching for performance optimization - Robust fallback system for unknown ROMs"""

import os
import re
import logging
import json
import hashlib
import threading
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Tuple, Optional, Union, Set, Callable
from functools import lru_cache
from collections import Counter, defaultdict
import pickle

# Configure logger
logger = logging.getLogger(__name__)

# Local imports
try:
    from src.detectors.base_detector import BaseDetector
    from src.detectors.ml_detector_fixed import RuleBasedConsoleDetector, detect_console_with_rules
    from src.utils.fuzzy_matching import get_similarity_score
except ImportError as e:
# Fallback implementations
    logger.warning(f"Fehler beim Importieren der notwendigen Module: {e}")

    BaseDetector = object

    def detect_console_with_rules(file_path, header_data=None):
        return "Unknown", 0.0, "fallback"

    class RuleBasedConsoleDetector:
        def __init__(self):
            pass
        def detect(self, file_path):
            return "Unknown", 0.0, "fallback"

    def get_similarity_score(a, b):
        return 0.0

# Configure logger
logger = logging.getLogger(__name__)

# Constant
_MODELS_PATH = os.path.join(os.path.dirname(__file__), '..', '..', 'models', 'ai_models')
_SIGNATURES_DB = os.path.join(_MODELS_PATH, 'rom_signatures.json')
_FEEDBACK_DB = os.path.join(_MODELS_PATH, 'user_feedback.json')
_MIN_CONFIDENCE = 0.7


class AIEnhancedROMDetector:
    """ROM detector with AI-like functions that works without external ML libraries. Uses header signatures, heuristics and user feedback for continuous improvement."""

    def __init__(self):
        """Initialisiere den KI-basierten Detector."""
        self.rule_detector = RuleBasedConsoleDetector()
        self.signatures = self._load_signatures()
        self.feedback_data = self._load_feedback()
        self._lock = threading.RLock()

# Make sure the model directory exists
        os.makedirs(_MODELS_PATH, exist_ok=True)

# Header signature cache
        self._header_cache = {}

    def _load_signatures(self) -> Dict[str, Dict[str, Any]]:
        """Use the Rome signatures from the JSON file."""
        if os.path.exists(_SIGNATURES_DB):
            try:
                with open(_SIGNATURES_DB, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Fehler beim Laden der ROM-Signaturen: {e}")

# Default signatures if the file does not exist or is incorrect
        default_signatures = {
            "header_patterns": {
                "Nintendo Entertainment System": {
                    "header_bytes": ["4E45531A"],  # "NES\x1A"
                    "offset": 0,
                    "confidence": 0.95
                },
                "Super Nintendo": {
                    "header_bytes": ["AABB"],  # SMC Header
                    "offset": 0,
                    "confidence": 0.9
                },
                "Nintendo 64": {
                    "header_bytes": ["80371240", "37804012"],  # N64 Boot-Code (beide Byte-Orders)
                    "offset": 0,
                    "confidence": 0.95
                },
                "Sega Genesis": {
                    "header_bytes": ["53454741"],  # "SEGA"
                    "offset": 0x100,  # Typische Position des SEGA-Headers
                    "confidence": 0.95
                },
                "PlayStation": {
                    "header_bytes": ["504C4159535441"], # "PLAYSTA"
                    "offset": 0,
                    "confidence": 0.9
                },
                "GameBoy": {
                    "header_bytes": ["CEED6666"],  # Teil des Nintendo-Logos im GB-Header
                    "offset": 0x104,
                    "confidence": 0.95
                },
                "GameBoy Advance": {
                    "header_bytes": ["24FFAE51699AA221"],  # Teil des Nintendo-Logos im GBA-Header
                    "offset": 0x4,
                    "confidence": 0.95
                }
            },
            "string_patterns": {
                "PlayStation": ["BOOT=cdrom:", "Sony Computer Entertainment"],
                "PlayStation 2": ["PS2DVD", "SCEI", "Sony Computer Entertainment Inc"],
                "Sega Saturn": ["SEGA SATURN", "SEGASATURN"],
                "Sega Dreamcast": ["SEGA DREAMCAST", "SEGADREAMCAST"],
                "GameCube": ["NINTENDO GAMECUBE", "dolphin"]
            },
            "file_ext_confidence": {
                ".nes": {"console": "Nintendo Entertainment System", "confidence": 0.9},
                ".smc": {"console": "Super Nintendo", "confidence": 0.85},
                ".sfc": {"console": "Super Nintendo", "confidence": 0.9},
                ".n64": {"console": "Nintendo 64", "confidence": 0.9},
                ".z64": {"console": "Nintendo 64", "confidence": 0.9},
                ".v64": {"console": "Nintendo 64", "confidence": 0.85},
                ".gb": {"console": "GameBoy", "confidence": 0.9},
                ".gbc": {"console": "GameBoy Color", "confidence": 0.9},
                ".gba": {"console": "GameBoy Advance", "confidence": 0.9},
                ".nds": {"console": "Nintendo DS", "confidence": 0.9},
                ".md": {"console": "Sega Genesis", "confidence": 0.85},
                ".gen": {"console": "Sega Genesis", "confidence": 0.85},
                ".iso": {"console": "Unknown CD-ROM", "confidence": 0.5},
                ".bin": {"console": "Unknown CD-ROM", "confidence": 0.5},
                ".cue": {"console": "Unknown CD-ROM", "confidence": 0.5}
            }
        }

# Save the default signatures
        try:
            with open(_SIGNATURES_DB, 'w', encoding='utf-8') as f:
                json.dump(default_signatures, f, indent=2)
        except Exception as e:
            logger.error(f"Fehler beim Speichern der Default-ROM-Signaturen: {e}")

        return default_signatures

    def _load_feedback(self) -> Dict[str, Any]:
        """Use the collected user feedback."""
        if os.path.exists(_FEEDBACK_DB):
            try:
                with open(_FEEDBACK_DB, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Fehler beim Laden des Benutzerfeedbacks: {e}")

# Default feedback data structure
        default_feedback = {
            "corrections": {},      # ROM-Hash -> Korrekte Konsole
            "confirmations": {},    # Rome -Hash -> Confirmed Console + Number
            "patterns": {},         # Found patterns with confidence
            "metadata": {
                "total_feedback": 0,
                "last_updated": None,
                "confidence_adjustments": {}
            }
        }

# Save the default structure
        try:
            with open(_FEEDBACK_DB, 'w', encoding='utf-8') as f:
                json.dump(default_feedback, f, indent=2)
        except Exception as e:
            logger.error(f"Fehler beim Speichern der Default-Feedback-Struktur: {e}")

        return default_feedback

    def detect_console(self, filename: str, content: Optional[bytes] = None) -> Tuple[str, float, str]:
        """Recognizes the console of a Rome with AI-like logic. Args: Filename: file name or path Content: Optional file content for header analysis Return: Tuple with (console name, confidence, identification method)"""
# Calculate the hash for feedback lookup (if content is available)
        rom_hash = None
        if content:
            rom_hash = hashlib.md5(content[:4096]).hexdigest()

# Check whether we already have feedback for this Rome
            if rom_hash in self.feedback_data["corrections"]:
                console = self.feedback_data["corrections"][rom_hash]
                return console, 1.0, "user_feedback"

# 1. Attempts Header-based detection when content is available
        if content and len(content) > 512:
            console, confidence = self._detect_by_header(content)
            if confidence >= _MIN_CONFIDENCE:
                return console, confidence, "header_signature"

# 2. Try file -based detection
        console, confidence = self.rule_detector.detect_console(filename)
        if confidence >= _MIN_CONFIDENCE:
            return console, confidence, "rule_based"

# 3. Attempts Fuzzy-Matching with known names when confidence is low
        if confidence < _MIN_CONFIDENCE:
            fuzzy_console, fuzzy_confidence = self._detect_by_fuzzy_matching(filename)
            if fuzzy_confidence > confidence:
                console, confidence = fuzzy_console, fuzzy_confidence
                if confidence >= _MIN_CONFIDENCE:
                    return console, confidence, "fuzzy_matching"

# 4.
        ext = os.path.splitext(filename.lower())[1]
        if ext in self.signatures["file_ext_confidence"]:
            ext_info = self.signatures["file_ext_confidence"][ext]
            if ext_info["confidence"] > confidence:
                return ext_info["console"], ext_info["confidence"], "extension"

# If a Suffed Confidence was not Reached
        if confidence < 0.4:
            return "Unknown", confidence, "low_confidence"

        return console, confidence, "combined"

    def _detect_by_header(self, content: bytes) -> Tuple[str, float]:
        """Recognizes the console based on Rome header signatures. Args: Content: Rome content Return: Tuple with (console name, confidence)"""
        best_match = None
        best_confidence = 0.0

# Check every header pattern
        for console, pattern_info in self.signatures["header_patterns"].items():
# Hole offset and header-bytes list
            offset = pattern_info.get("offset", 0)
            header_bytes_list = pattern_info.get("header_bytes", [])
            base_confidence = pattern_info.get("confidence", 0.8)

# Make sure we have enough bytes to compare
            for header_hex in header_bytes_list:
                header_bytes = bytes.fromhex(header_hex)
                header_len = len(header_bytes)

# Check whether there is enough content
                if len(content) < offset + header_len:
                    continue

# Extract the relevant part of the content
                content_part = content[offset:offset+header_len]

# Compare the bytes
                if content_part == header_bytes:
                    if base_confidence > best_confidence:
                        best_confidence = base_confidence
                        best_match = console

# Check also on string patterns in the Rome
        content_str = content[:4096].decode('ascii', errors='ignore')
        for console, patterns in self.signatures["string_patterns"].items():
            for pattern in patterns:
                if pattern in content_str:
                    match_confidence = 0.85  # Etwas geringere Konfidenz als exakte Header-Matches
                    if match_confidence > best_confidence:
                        best_confidence = match_confidence
                        best_match = console

        if best_match:
            return best_match, best_confidence
        else:
            return "Unknown", 0.0

    def _detect_by_fuzzy_matching(self, filename: str) -> Tuple[str, float]:
        """Uses fuzzy matching to compare ROM names with known patterns. Args: Filename: file name Return: Tuple with (console name, confidence)"""
        basename = os.path.basename(filename).lower()

# Extract tokens from the file name
        tokens = set(re.findall(r'\w+', basename))

# Frequent console names and their aliaasse
        console_keywords = {
            "Nintendo Entertainment System": {"nes", "nintendo", "famicom", "8bit", "8-bit"},
            "Super Nintendo": {"snes", "sfc", "superfamicom", "supernintendo", "16bit", "16-bit"},
            "Nintendo 64": {"n64", "nintendo64", "64bit", "64-bit"},
            "GameBoy": {"gb", "gameboy", "dmg", "pocket"},
            "GameBoy Color": {"gbc", "gameboycolor", "color", "colour"},
            "GameBoy Advance": {"gba", "gameboyadvance", "advance", "advanced"},
            "Nintendo DS": {"nds", "nintendods", "dualscreen"},
            "PlayStation": {"psx", "ps1", "playstation", "psone"},
            "PlayStation 2": {"ps2", "playstation2", "dvd"},
            "Sega Genesis": {"genesis", "megadrive", "md", "sega16"},
            "Sega Saturn": {"saturn", "segasaturn"},
            "Sega Dreamcast": {"dreamcast", "segadreamcast", "dc"},
            "Atari 2600": {"atari", "2600", "vcs"},
        }

        best_match = None
        best_score = 0.0

# Find the best match between tokens and console keywords
        for console, keywords in console_keywords.items():
            intersection = tokens.intersection(keywords)
            if intersection:
# Calculate A Score Based on the Number of Matching Keywords
# and their relevance for the file name
                score = min(0.95, len(intersection) * 0.2 + 0.6)

                if score > best_score:
                    best_score = score
                    best_match = console

        if best_match:
            return best_match, best_score
        else:
            return "Unknown", 0.0

    def add_feedback(self, filename: str, content: Optional[bytes], detected_console: str,
                    correct_console: str, user_confidence: float = 1.0) -> bool:
        """Add user feedback to the recognition database. Args: Filename: File name of the Rome Content: Rome content (if available) detected_console: originally recognized console correct_console: correct console specified by the user User_confidence: Confidence given by the user (1.0 = safe) Return: True when the feedback has been successfully added"""
        try:
            with self._lock:
# Calculate the Rome Hash if available
                rom_hash = None
                if content:
                    rom_hash = hashlib.md5(content[:4096]).hexdigest()
                else:
# Without Content We Use the File Name as a Weak Replacement
                    rom_hash = hashlib.md5(filename.encode('utf-8')).hexdigest() + "_namehash"

# Update the feedback data
                if detected_console != correct_console:
# This is a correction
                    self.feedback_data["corrections"][rom_hash] = correct_console

# Also update the confidence adjustments
                    if detected_console not in self.feedback_data["metadata"]["confidence_adjustments"]:
                        self.feedback_data["metadata"]["confidence_adjustments"][detected_console] = -0.05
                    else:
# Reduce the confidence for incorrect recognitions
                        current = self.feedback_data["metadata"]["confidence_adjustments"][detected_console]
                        self.feedback_data["metadata"]["confidence_adjustments"][detected_console] = max(-0.3, current - 0.05)
                else:
# This is a confirmation
                    if rom_hash not in self.feedback_data["confirmations"]:
                        self.feedback_data["confirmations"][rom_hash] = {
                            "console": correct_console,
                            "count": 1
                        }
                    else:
                        self.feedback_data["confirmations"][rom_hash]["count"] += 1

# Increase the confidence for correct recognitions
                    if correct_console not in self.feedback_data["metadata"]["confidence_adjustments"]:
                        self.feedback_data["metadata"]["confidence_adjustments"][correct_console] = 0.02
                    else:
                        current = self.feedback_data["metadata"]["confidence_adjustments"][correct_console]
                        self.feedback_data["metadata"]["confidence_adjustments"][correct_console] = min(0.2, current + 0.02)

# Extract patterns from the file name for future improvements
                self._extract_patterns(filename, correct_console, user_confidence)

# Update metadata
                self.feedback_data["metadata"]["total_feedback"] = self.feedback_data["metadata"].get("total_feedback", 0) + 1
                self.feedback_data["metadata"]["last_updated"] = datetime.now().isoformat()

# Saving updated feedback data
                with open(_FEEDBACK_DB, 'w', encoding='utf-8') as f:
                    json.dump(self.feedback_data, f, indent=2)

                logger.info(f"Benutzerfeedback für '{os.path.basename(filename)}' hinzugefügt: {detected_console} -> {correct_console}")
                return True

        except Exception as e:
            logger.error(f"Fehler beim Hinzufügen von Benutzerfeedback: {e}")
            return False

    def _extract_patterns(self, filename: str, console: str, confidence: float) -> None:
        """Extracts patterns from the file name for future learning. Args: Filename: File name of the Rome Console: Correct console platform Confidence: Confidence of the assignment"""
        basename = os.path.basename(filename).lower()

# Extract tokens and N-grammels
        tokens = re.findall(r'\w+', basename)
        ext = os.path.splitext(basename)[1].lower()

# Update token statistics
        for token in tokens:
            if token not in self.feedback_data["patterns"]:
                self.feedback_data["patterns"][token] = {}

            if console not in self.feedback_data["patterns"][token]:
                self.feedback_data["patterns"][token][console] = {
                    "count": 1,
                    "confidence": confidence
                }
            else:
                current = self.feedback_data["patterns"][token][console]
                self.feedback_data["patterns"][token][console] = {
                    "count": current["count"] + 1,
                    "confidence": (current["confidence"] * current["count"] + confidence) / (current["count"] + 1)
                }

# Update expansion statistics
        if ext:
            if ext not in self.signatures["file_ext_confidence"]:
                self.signatures["file_ext_confidence"][ext] = {
                    "console": console,
                    "confidence": 0.7  # Start with a careful confidence
                }
            elif self.signatures["file_ext_confidence"][ext]["console"] == console:
# Increase the confidence when the assignment is confirmed
                current = self.signatures["file_ext_confidence"][ext]["confidence"]
                self.signatures["file_ext_confidence"][ext]["confidence"] = min(0.95, current + 0.02)
            else:
# If we have contradictory data, reduce the confidence
                current = self.signatures["file_ext_confidence"][ext]["confidence"]
                self.signatures["file_ext_confidence"][ext]["confidence"] = max(0.4, current - 0.1)

# Saving updated signatures
        try:
            with open(_SIGNATURES_DB, 'w', encoding='utf-8') as f:
                json.dump(self.signatures, f, indent=2)
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der ROM-Signaturen: {e}")


# Global detector for uniform access
_ai_detector = None

def get_ai_detector() -> AIEnhancedROMDetector:
    """Gives back a global AI detector instance. Return: An instance of AienhacedromDetector"""
    global _ai_detector
    if _ai_detector is None:
        _ai_detector = AIEnhancedROMDetector()
    return _ai_detector


def detect_console_with_ai(filename: str, content: Optional[bytes] = None) -> Tuple[str, float, Dict[str, Any]]:
    """High level function for ROM console detection with extended AI-like logic. Args: Filename: file name or path Content: Optional file content for header analysis Return: Tuple with (console name, confidence, metadata dictionary)"""
    detector = get_ai_detector()
    console, confidence, method = detector.detect_console(filename, content)

# Metadata for transparency and debug
    metadata = {
        "method": method,
        "confidence": confidence,
        "console": console,
        "filename": os.path.basename(filename)
    }

    return console, confidence, metadata


# Feedback function for user interaction
def add_user_feedback(filename: str, content: Optional[bytes], detected_console: str,
                     correct_console: str, user_confidence: float = 1.0) -> bool:
    """Add user feedback to the AI ​​recognition database. Args: Filename: File name of the Rome Content: Rome content (if available) detected_console: originally recognized console correct_console: correct console specified by the user User_confidence: Confidence given by the user (1.0 = safe) Return: True when the feedback has been successfully added"""
    detector = get_ai_detector()
    return detector.add_feedback(filename, content, detected_console, correct_console, user_confidence)
