"""ROM SARTER PRO - central detector interface This file provides a central interface for all ROM detectors, to offer a consistent API for console detection. Features: - Uniform API for all identification methods - Automatic Fallback mechanism - performance optimization through caching - Context -conscious detection - Specialized detectors for certain formats (CHD, archive) - Database integration for maximum accuracy (no-intro & redump) Use: From src.detectors Import Detect_Console Console, Confidence = Detect_Console (File Name, File_Path)"""

import os
import sqlite3
from typing import Dict, Tuple, Optional, Any, List
from functools import lru_cache
import logging
import hashlib
from pathlib import Path

# Import Detection Methods from Specialized Module
from src.detectors.console_detector import detect_console_fast
from src.core.file_utils import calculate_file_hash
from src.utils.performance_enhanced import measure_time

# Alias for downward compatibility
calculate_md5_fast = calculate_file_hash

# Import Specialized Detectors
from .console_detector import detect_console_enhanced
from .archive_detector import detect_console_from_archive, is_archive_file
from .chd_detector import detect_console_from_chd, is_chd_file
from .ml_detector import detect_console_with_ml, MLEnhancedConsoleDetector, get_ml_detector

# Database connections
from src.database.connection_pool import ROM_DATABASE_PATH, database_connection

# Configure logger
logger = logging.getLogger(__name__)

# Import database initialization
try:
    from src.database.db_gui_integration import initialize_database
except ImportError:
# Fallback implementation if DB_Gui_integration is not available
    def initialize_database(db_path):
        """Fallback initialization of the database."""
        try:
            os.makedirs(os.path.dirname(db_path), exist_ok=True)
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("""
            CREATE TABLE IF NOT EXISTS roms (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                console TEXT NOT NULL,
                filename TEXT,
                crc TEXT,
                md5 TEXT,
                sha1 TEXT,
                size INTEGER,
                metadata TEXT,
                source TEXT,
                confidence REAL DEFAULT 1.0,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
            """)
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_roms_md5 ON roms(md5)")
            conn.commit()
            conn.close()
            logger.info(f"Datenbank initialisiert: {db_path}")
            return True
        except Exception as e:
            logger.error(f"Fehler bei der Datenbankinitialisierung: {e}")
            return False

# Try to import the database module
try:
    from src.database.db_debug import debug_database_initialization
except ImportError:
    def debug_database_initialization(db_path):
        """Fallback for Debug-Function."""
        logger.debug(f"Überprüfe Datenbank: {db_path}")
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tables = cursor.fetchall()
            logger.debug(f"Vorhandene Tabellen: {tables}")
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Fehler bei der Datenbankprüfung: {e}")
            return False

# Constant
CACHE_SIZE = 10000
HIGH_CONFIDENCE_THRESHOLD = 0.85
ACCEPTABLE_CONFIDENCE_THRESHOLD = 0.65
DATABASE_ENABLED = True  # Switch for database functionality

@lru_cache(maxsize=CACHE_SIZE)
def detect_console_by_database(file_path: str) -> Tuple[str, float]:
    """Recognizes the console of a Rome by comparing the Rome database. This function calculates the MD5-Hash of the file and compares it the entries in the database. In the event of a hit, the corresponding Console returned with the highest confidence. Args: File_Path: Complete path to the Rome file Return: Tuble from (console_name, confidence_score)"""
    if not DATABASE_ENABLED or not file_path or not os.path.exists(file_path):
        return "Unknown", 0.0

    try:
# Check whether the database exists
        if not os.path.exists(ROM_DATABASE_PATH):
            logger.info("ROM-Datenbank nicht gefunden. Initialisiere neue Datenbank unter: %s", ROM_DATABASE_PATH)
            if not initialize_database(ROM_DATABASE_PATH):
                return "Unknown", 0.0

# For additional diagnosis
            from src.database.db_debug import debug_database_initialization
            debug_database_initialization(ROM_DATABASE_PATH)

# Calculate hash values for the file
        md5_hash = calculate_md5_fast(file_path)
        if not md5_hash:
            return "Unknown", 0.0

# Use the secure context manager for database connections
        from src.database.connection_pool import database_connection

        try:
            with database_connection(ROM_DATABASE_PATH) as conn:
                cursor = conn.cursor()
# Search for MD5-Hash
                cursor.execute("SELECT console, name, confidence FROM roms WHERE md5=?", (md5_hash,))
                result = cursor.fetchone()

                if result:
                    console, name, db_confidence = result
                    logger.info(f"ROM in Datenbank gefunden: {name} ({console})")
# Use the confidence stored in the database, but at least 0.95
                    return console, max(float(db_confidence), 0.95)

# If necessary, query additional hash types
# SHA1, CRC32 etc. (can be implemented here)

        except sqlite3.OperationalError as e:
            if "no such table" in str(e):
# Table does not exist, initialize the database
                logger.warning("Tabelle 'roms' nicht gefunden, initialisiere Datenbank...")
                initialize_database(ROM_DATABASE_PATH)
# Try again after initialization
                try:
                    with database_connection(ROM_DATABASE_PATH) as conn:
                        cursor = conn.cursor()
                        cursor.execute("SELECT console, name, confidence FROM roms WHERE md5=?", (md5_hash,))
                        result = cursor.fetchone()

                        if result:
                            console, name, db_confidence = result
                            logger.info(f"ROM in Datenbank gefunden: {name} ({console})")
                            return console, max(float(db_confidence), 0.95)
                except Exception as retry_error:
                    logger.error(f"Fehler beim zweiten Versuch der Datenbankabfrage: {retry_error}")
            else:
                logger.error(f"Datenbankfehler: {e}")

        return "Unknown", 0.0

    except Exception as e:
        logger.warning(f"Fehler bei der Datenbank-Erkennung: {e}")
        return "Unknown", 0.0


# Constants for the detector configuration
HIGH_CONFIDENCE_THRESHOLD = 0.85
ACCEPTABLE_CONFIDENCE_THRESHOLD = 0.65
DATABASE_ENABLED = True
CACHE_SIZE = 1000


class DetectionResult:
    """Class for representing a detection result with metadata. This class stores both the detection result (console, confidence) as well as metadata for the identification method used and the file path."""

    def __init__(self, console: str = "Unknown", confidence: float = 0.0,
                 method: str = "unknown", file_path: str = "", metadata: Dict[str, Any] = None):
        """Initialized a new detection result. Args: Console: Name of the recognized console Confidence: Confidence level (0.0-1.0) Method: Used identification method File_Path: path of the examined file Metadata: Optional additional metadata for detection"""
        self.console = console
        self.confidence = float(max(0.0, min(1.0, confidence)))  # Limit between 0 and 1
        self.method = method
        self.file_path = file_path
        self.metadata = metadata or {}

# Derivated properties
        self.is_confident = self.confidence >= HIGH_CONFIDENCE_THRESHOLD
        self.is_acceptable = self.confidence >= ACCEPTABLE_CONFIDENCE_THRESHOLD
        self.is_unknown = self.console == "Unknown" or self.confidence < 0.3

    def to_tuple(self) -> Tuple[str, float]:
        """Gives the result back as (Console, Confidence) Tuple."""
        return (self.console, self.confidence)

    @staticmethod
    def from_tuple(result: Tuple[str, float], method: str = "unknown", file_path: str = "") -> 'DetectionResult':
        """Creates a detection result from a (Console, Confidence) taple."""
        console, confidence = result
        return DetectionResult(console, confidence, method=method, file_path=file_path)

    def __str__(self) -> str:
        """String-Darstellung des Ergebnisses."""
        confidence_percent = int(self.confidence * 100)
        confidence_str = f"{confidence_percent}%"

        if self.is_confident:
            status = "SICHER"
        elif self.is_acceptable:
            status = "AKZEPTABEL"
        else:
            status = "UNSICHER"

        return f"{self.console} ({confidence_str}, {status})"

    def to_dict(self) -> Dict[str, Any]:
        """Converts the result into a dictionary for JSON SEARIALIALIES."""
        return {
            "console": self.console,
            "confidence": self.confidence,
            "is_confident": self.is_confident,
            "is_acceptable": self.is_acceptable,
            "is_unknown": self.is_unknown,
            **self.metadata
        }


class DetectionManager:
    """Central manager class for the administration and coordination of all detectors. Implements the singleton pattern to offer a global access point."""

    _instance = None

    @classmethod
    def get_instance(cls):
        """Gives back the singleton instance."""
        if cls._instance is None:
            cls._instance = DetectionManager()
        return cls._instance

    def __init__(self):
        """Initializes the detection manager with the standard detectors."""
# Cache for results
        self._cache = {}
        self._cache_size = CACHE_SIZE

# statistics
        self.stats = {
            "total_detections": 0,
            "cache_hits": 0,
            "high_confidence": 0,
            "acceptable_confidence": 0,
            "low_confidence": 0,
            "unknown": 0,
            "archive_detections": 0,
            "chd_detections": 0,
            "standard_detections": 0
        }

    def detect_console(self, filename: str, file_path: Optional[str] = None) -> Tuple[str, float]:
        """Recognize the console for a file by automatically selecting the right detector. Args: Filename: Name of the Rome file File_Path: Optional full file path for context analysis Return: Tuble from (console name, confidence value)"""
        result = self.detect_console_with_metadata(filename, file_path)
        return result.console, result.confidence

    def detect_console_with_metadata(self, filename: str, file_path: Optional[str] = None) -> DetectionResult:
        """Recognize the console for a file with complete metadata. Args: Filename: Name of the Rome file File_Path: Optional full file path for context analysis Return: Detection result object with console, confidence and metadata"""
        try:
# Update statistics
            self.stats["total_detections"] += 1

# Check cache
            cache_key = f"{filename}|{file_path}"
            if cache_key in self._cache:
                self.stats["cache_hits"] += 1
                return self._cache[cache_key]

# Recognize the file type
            file_path_str = str(file_path) if file_path else None

# Check on archive files
            if file_path_str and is_archive_file(file_path_str):
                self.stats["archive_detections"] += 1
                console, confidence = detect_console_from_archive(file_path_str)
                result = DetectionResult(console, confidence, {"type": "archive"})

# Check on CHD files
            elif file_path_str and is_chd_file(file_path_str):
                self.stats["chd_detections"] += 1
                console, confidence = detect_console_from_chd(file_path_str)
                result = DetectionResult(console, confidence, {"type": "chd"})

# Database-based recognition (maximum priority)
            elif DATABASE_ENABLED and file_path_str and os.path.exists(file_path_str):
                db_console, db_confidence = detect_console_by_database(file_path_str)
                if db_confidence > 0.9:  # Very high confidence in database hits
                    result = DetectionResult(db_console, db_confidence, method="database", file_path=file_path_str)
                else:
# Try AI-based detection (newly implemented)
                    self.stats["ml_detections"] = self.stats.get("ml_detections", 0) + 1
                    ml_result = detect_console_with_ml(file_path_str)

# If the AI detection has high confidence, use it
                    if ml_result.confidence >= 0.8:
                        return ml_result

# Otherwise standard detection for normal ROM files
                    self.stats["standard_detections"] += 1
                    console, confidence = detect_console_enhanced(filename, file_path_str)

# Combine both results at medium confidence
                    if 0.5 <= ml_result.confidence < 0.8 and 0.5 <= confidence < 0.9:
# When the same console has been recognized, the confidence increases
                        if ml_result.console == console:
                            combined_confidence = min(0.95, ml_result.confidence + 0.1)
                            result = DetectionResult(
                                console, combined_confidence,
                                method="ml_enhanced_combined", file_path=file_path_str
                            )
                        elif ml_result.confidence > confidence:
                            result = ml_result
                        else:
                            result = DetectionResult(console, confidence, method="enhanced", file_path=file_path_str)
# If low confidence, also try standard detection
                    elif confidence < ACCEPTABLE_CONFIDENCE_THRESHOLD:
                        std_console, std_confidence = detect_console_fast(filename, file_path_str)
                        if std_confidence > confidence and std_confidence > ml_result.confidence:
                            result = DetectionResult(std_console, std_confidence, method="standard_fallback", file_path=file_path_str)
                        elif ml_result.confidence > confidence:
                            result = ml_result
                        else:
                            result = DetectionResult(console, confidence, method="enhanced", file_path=file_path_str)
                    else:
                        result = DetectionResult(console, confidence, method="enhanced", file_path=file_path_str)
            else:
# Try AI-based detection if the file exists
                if file_path_str and os.path.exists(file_path_str):
                    self.stats["ml_detections"] = self.stats.get("ml_detections", 0) + 1
                    ml_result = detect_console_with_ml(file_path_str)

                    if ml_result.confidence >= 0.7:
                        return ml_result

# Standard Detection Without A Database
                self.stats["standard_detections"] += 1
                console, confidence = detect_console_enhanced(filename, file_path_str)
                result = DetectionResult(console, confidence, method="enhanced", file_path=file_path_str)

# Update confidence statistics
            if result.is_unknown:
                self.stats["unknown"] += 1
            elif result.is_confident:
                self.stats["high_confidence"] += 1
            elif result.is_acceptable:
                self.stats["acceptable_confidence"] += 1
            else:
                self.stats["low_confidence"] += 1

# Result cachen
            if len(self._cache) >= self._cache_size:
# Cache cleaning: Remove the oldest entry
                try:
                    self._cache.pop(next(iter(self._cache)))
                except (StopIteration, KeyError):
                    pass

            self._cache[cache_key] = result

            return result
        except Exception as e:
            logger.error(f"Fehler bei der Konsolenerkennung: {e}")
            return DetectionResult("Unknown", 0.0, {"error": str(e)})

    def get_statistics(self) -> Dict[str, Any]:
        """Returns the current identification statistics."""
        return dict(self.stats)

    def clear_cache(self) -> None:
        """Leert den Ergebniscache."""
        self._cache.clear()
        logger.debug("Detektorcache geleert")


# Simple API function for downward compatibility
def detect_console(filename: str, file_path: Optional[str] = None) -> Tuple[str, float]:
    """Central function for console detection, which automatically selects the suitable detector. Args: Filename: Name of the Rome file File_Path: Optional full file path for context analysis Return: Tuble from (console name, confidence value)"""
    return DetectionManager.get_instance().detect_console(filename, file_path)


def get_console_list() -> Dict[str, Dict[str, Any]]:
    """Provides a comprehensive list of supported consoles with metadata. Return: Dictionary with console names and associated metadata"""
    try:
# First try to use the new console database
        from src.database.console_db import get_console_metadata_all
        return get_console_metadata_all()
    except ImportError:
# Fallback to the old console database
        try:
            from src.utils import ENHANCED_CONSOLE_DATABASE

# Convert the console database into a dictionary
            consoles = {}
            for console_name, meta in ENHANCED_CONSOLE_DATABASE.items():
                consoles[console_name] = {
                    'display_name': console_name,
                    'extensions': meta.extensions if hasattr(meta, 'extensions') else [],
                    'manufacturer': meta.manufacturer if hasattr(meta, 'manufacturer') else 'Unknown',
                    'year': meta.release_year if hasattr(meta, 'release_year') else 'Unknown',
                    'type': meta.console_type if hasattr(meta, 'console_type') else 'Unknown'
                }
            return consoles
        except Exception as e:
            logger.error(f"Fehler beim Laden der Konsolendatenbank: {e}")
            return {}
