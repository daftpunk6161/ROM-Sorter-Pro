#!/usr/bin/env python3
# -*-coding: utf-8-*-
"""ROM SARTER PRO - Safety validation This module contains functions for the safe validation of paths And user inputs to prevent directory traversal and other attacks."""

import os
import re
import logging
import sys
from pathlib import Path
from typing import Optional, List, Dict, Any, Union

logger = logging.getLogger(__name__)


class SecurityError(Exception):
    """Basic class for safety -relevant error."""
    pass


class InvalidPathError(SecurityError):
    """Error in invalid or uncertain paths."""
    pass


def is_valid_directory(path: Union[str, Path], must_exist: bool = True) -> bool:
    """Check whether a path is a valid directory. Args: Path: The directory path to be tested must_exist: whether the directory must exist Return: True if the path is a valid directory"""
    try:
        path_obj = Path(path).resolve()

# Check for existence
        if must_exist and not path_obj.exists():
            logger.warning(f"Verzeichnis existiert nicht: {path_obj}")
            return False

# Check Whether it is a directory (or could be)
        if path_obj.exists() and not path_obj.is_dir():
            logger.warning(f"Pfad ist kein Verzeichnis: {path_obj}")
            return False

# Check on suspicious paths
        suspicious_patterns = [
            r'\\\\', r'\.\.'  # Double backslashes or directory traversal
        ]
        path_str = str(path_obj)
        for pattern in suspicious_patterns:
            if re.search(pattern, path_str):
                logger.warning(f"Verdächtiger Pfad erkannt: {path_obj} (Muster: {pattern})")
                return False

        return True

    except Exception as e:
        logger.error(f"Fehler bei der Pfadvalidierung von {path}: {e}")
        return False


def sanitize_path(path: str) -> str:
    """Adjusted a path to make it safer. Args: Path: The path to be adjusted Return: Cleaning path"""
    if not path:
        return ""

# Save the original scouting sign
    orig_sep = '/' if '/' in path and '\\' not in path else os.path.sep

# Normalize the path
    normalized = os.path.normpath(path)

# Remove potentially dangerous sequences
    sanitized = re.sub(r'\.\.[/\\]', '', normalized)

# Restore the original scout separator
    if orig_sep == '/' and os.path.sep == '\\':
        sanitized = sanitized.replace('\\', '/')

    return sanitized


def validate_file_operation(file_path: Union[str, Path],
                          base_dir: Optional[Union[str, Path]] = None,
                          allow_read: bool = True,
                          allow_write: bool = True) -> bool:
    """Validates a file surgery in terms of security. Check whether the file path is safe and is within the permitted area. Args: File_Path: The file path to be validated base_dir: The basic directory in which the file should be Allow_read: Whether reading access is allowed Allow_write: Whether writing access is allowed Return: True when the operation is safe Raises: Invalid Pather: If the path is unsure"""
# Convert to path objects
    file_path = Path(file_path).resolve()

# Check basic directory, if specified
    if base_dir:
        base_dir = Path(base_dir).resolve()

# Make sure the file is in the basic directory
        if not str(file_path).startswith(str(base_dir)):
            logger.warning(f"Security warning: File access outside base directory denied: {file_path}")
            raise InvalidPathError(f"File access outside allowed directory: {file_path}")

# Check special directories
    sensitive_dirs = ['/etc', '/var/log', '/root', '/boot', '/bin', '/sbin',
                     'C:\\Windows', 'C:\\Program Files', 'C:\\Users\\Administrator']

    for sensitive in sensitive_dirs:
        if str(file_path).startswith(sensitive):
            logger.warning(f"Security warning: Access to protected directory denied: {file_path}")
            raise InvalidPathError(f"Access to protected directory not allowed: {file_path}")

# Check for hidden files (Unix) and system files (Windows)
    if file_path.name.startswith('.') and sys.platform != 'win32':
        logger.warning(f"Warning: Access to hidden file: {file_path}")

# Check whether writing access is required, but is not allowed
    if not allow_write and file_path.exists() and os.access(str(file_path), os.W_OK):
        logger.warning(f"Security warning: Write access not allowed for: {file_path}")
        raise InvalidPathError(f"Write access not allowed for: {file_path}")

# Check whether reading access is needed, but is not allowed
    if not allow_read and file_path.exists() and os.access(str(file_path), os.R_OK):
        logger.warning(f"Security warning: Read access not allowed for: {file_path}")
        raise InvalidPathError(f"Read access not allowed for: {file_path}")

    return True


def check_environment_security() -> Dict[str, Any]:
    """
    Checks the security of the execution environment.

    Returns:
        Dict with security information and warnings
    """
    results = {
        'security_warnings': [],
        'is_secure': True
    }

# Check authorizations of the current directory
    try:
        current_dir = os.path.dirname(os.path.abspath(__file__))
        if os.access(current_dir, os.W_OK):
# Current directory permits are okay
            pass
    except Exception as e:
        results['security_warnings'].append(f"Could not check permissions: {e}")
        results['is_secure'] = False

# Check Python version
    if sys.version_info < (3, 8):
        results['security_warnings'].append(
            f"Outdated Python version {sys.version}. Version 3.8 or higher recommended."
        )

# Check on uncertain environment variables
    if os.environ.get('PYTHONHTTPSVERIFY') == '0':
        results['security_warnings'].append(
            "PYTHONHTTPSVERIFY=0 found. SSL certificate verification is disabled."
        )
        results['is_secure'] = False

    if results['security_warnings']:
        for warning in results['security_warnings']:
            logger.warning(f"Security warning: {warning}")

    return results


def validate_input(input_value: str, max_length: int = 255, pattern: Optional[str] = None) -> str:
    """Validated and adjusted a user input. Args: input_value: The entry to be validated Max_length: Maximum permissible length Patterns: Optional regex pattern for valid inputs Return: The adjusted input Raises: Security terror: If the input is invalid or potentially dangerous"""
    if not input_value:
        return ""

# Length check
    if len(input_value) > max_length:
        raise SecurityError(f"Eingabe überschreitet maximale Länge von {max_length} Zeichen")

# Remove potentially dangerous signs
    sanitized = re.sub(r'[;<>&\'"()]', '', input_value)

# Check against patterns, if specified
    if pattern and not re.fullmatch(pattern, sanitized):
        raise SecurityError(f"Eingabe entspricht nicht dem erlaubten Muster: {pattern}")

    return sanitized
