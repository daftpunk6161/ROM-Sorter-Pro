#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ROM Sorter Pro - Optimiertes Leistungsüberwachungsmodul

Diese Datei ist eine konsolidierte Version der Performance-Überwachungstools.
Sie kombiniert die Funktionalität aus src/core/performance.py und src/utils/performance.py
für bessere Wartbarkeit und reduzierte Redundanz.

Verbesserte Features:
- Optimierte Memory-Nutzung
- Verbesserte Thread-Sicherheit
- Erweitertes Metriken-Tracking
- Vereinheitlichte API für alle Komponenten
- Automatische Ressourcen-Freigabe
"""

import os
import time
import threading
import functools
import gc
import logging
import sys
from typing import Dict, List, Any, Optional, Union, Callable, TypeVar
from collections import defaultdict, deque
from datetime import datetime, timedelta
from contextlib import contextmanager

# Typdefinitionen für Generics
T = TypeVar('T')
F = TypeVar('F', bound=Callable[..., Any])

# Optional: Psutil für erweiterte Systemmetriken verwenden falls verfügbar
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

logger = logging.getLogger(__name__)


def measure_time(func=None, name=None, log_level=logging.DEBUG):
    """
    Optimierter Dekorator zur Messung der Ausführungszeit einer Funktion.

    Args:
        func: Die zu dekorierende Funktion
        name: Optionaler Name für das Logging (Standard: Funktionsname)
        log_level: Das Log-Level für die Zeitmessung

    Returns:
        Die dekorierte Funktion
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            operation_name = name or func.__name__
            start_time = time.perf_counter()  # Präzisere Zeitmessung
            try:
                result = func(*args, **kwargs)
                return result
            finally:
                end_time = time.perf_counter()
                duration = end_time - start_time
                logger.log(log_level, f"Operation '{operation_name}' dauerte {duration:.4f} Sekunden")
                
                # Optional: An PerformanceMonitor senden, wenn verfügbar
                try:
                    monitor = PerformanceMonitor.get_instance()
                    monitor.record_operation_time(operation_name, duration)
                except (NameError, AttributeError):
                    pass  # Monitor nicht verfügbar, ignorieren
        return wrapper

    # Ermöglicht die Verwendung mit oder ohne Argumente
    if func is None:
        return decorator
    return decorator(func)


class PerformanceMetric:
    """Speichert Leistungsmetriken für eine Operation."""

    def __init__(self, name: str, max_samples: int = 100):
        """
        Initialisiert eine neue Leistungsmetrik.

        Args:
            name: Name der Metrik
            max_samples: Maximale Anzahl zu speichernder Samples
        """
        self.name = name
        self.max_samples = max_samples
        self.durations = deque(maxlen=max_samples)
        self.start_times = {}
        self.lock = threading.RLock()

        # Spezielle Tracking-Variablen
        self.last_duration = 0.0
        self.total_duration = 0.0
        self.count = 0
        self.failed = 0
        self._min = float('inf')
        self._max = float('-inf')

        # Multi-Phase-Metriken
        self.phase_durations = defaultdict(float)
        self.current_phase = None

    def start(self, key: Optional[Any] = None) -> float:
        """
        Startet die Zeitmessung.

        Args:
            key: Optionaler Schlüssel für mehrere parallele Messungen

        Returns:
            Aktuelle Zeit als Startzeit
        """
        key = key if key is not None else 'default'
        with self.lock:
            start_time = time.perf_counter()
            self.start_times[key] = start_time
            return start_time

    def stop(self, key: Optional[Any] = None, success: bool = True) -> float:
        """
        Stoppt die Zeitmessung und speichert die Dauer.

        Args:
            key: Schlüssel der gestarteten Messung
            success: Ob die Operation erfolgreich war

        Returns:
            Dauer in Sekunden

        Raises:
            KeyError: Wenn kein Start für den angegebenen Schlüssel existiert
        """
        key = key if key is not None else 'default'
        with self.lock:
            if key not in self.start_times:
                raise KeyError(f"Kein Start für Schlüssel '{key}' gefunden")

            end_time = time.perf_counter()
            start_time = self.start_times.pop(key)
            duration = end_time - start_time

            self.durations.append(duration)
            self.last_duration = duration
            self.total_duration += duration
            self.count += 1

            if not success:
                self.failed += 1

            # Aktualisiere Min/Max
            if duration < self._min:
                self._min = duration
            if duration > self._max:
                self._max = duration

            return duration


class PerformanceMonitor:
    """
    Optimierter und konsolidierter Leistungsmonitor für ROM Sorter Pro.
    Singleton-Implementierung für den einfachen Zugriff aus allen Komponenten.
    """

    _instance = None
    _lock = threading.RLock()

    @classmethod
    def get_instance(cls):
        """Gibt die Singleton-Instanz des Monitors zurück."""
        with cls._lock:
            if cls._instance is None:
                cls._instance = PerformanceMonitor()
            return cls._instance

    def __init__(self):
        """Initialisiert den Leistungsmonitor."""
        self.metrics = {}
        self.operation_times = defaultdict(list)
        self.operation_counts = defaultdict(int)
        self.memory_snapshots = []
        self.peak_memory = 0
        self.start_time = time.perf_counter()
        self._lock = threading.RLock()
        
        # Memory-Monitoring starten
        self._last_memory_check = 0
        self._memory_check_interval = 5  # Sekunden
        
        # Speichermetriken initialisieren
        self._update_memory_usage()

    def record_operation_time(self, operation_name: str, duration: float) -> None:
        """
        Zeichnet die Zeit einer Operation auf.

        Args:
            operation_name: Name der Operation
            duration: Dauer in Sekunden
        """
        with self._lock:
            self.operation_times[operation_name].append(duration)
            self.operation_counts[operation_name] += 1
            
            # Regelmäßig Memory-Nutzung aktualisieren
            current_time = time.perf_counter()
            if current_time - self._last_memory_check > self._memory_check_interval:
                self._update_memory_usage()
                self._last_memory_check = current_time

    def start_operation(self, operation_name: str) -> float:
        """
        Beginnt die Zeitmessung für eine Operation.

        Args:
            operation_name: Name der Operation

        Returns:
            Startzeit in Sekunden
        """
        start_time = time.perf_counter()
        with self._lock:
            if operation_name not in self.metrics:
                self.metrics[operation_name] = PerformanceMetric(operation_name)
            self.metrics[operation_name].start()
        return start_time

    def end_operation(self, operation_name: str, start_time: float = None) -> float:
        """
        Beendet die Zeitmessung für eine Operation.

        Args:
            operation_name: Name der Operation
            start_time: Optional, wenn nicht über start_operation gestartet

        Returns:
            Dauer in Sekunden
        """
        end_time = time.perf_counter()
        
        with self._lock:
            if operation_name in self.metrics:
                duration = self.metrics[operation_name].stop()
            elif start_time is not None:
                duration = end_time - start_time
                self.record_operation_time(operation_name, duration)
            else:
                raise ValueError(f"Operation '{operation_name}' wurde nicht gestartet")
                
        return duration

    def _update_memory_usage(self) -> Dict[str, Any]:
        """
        Aktualisiert die Speichernutzungsstatistik.

        Returns:
            Speichernutzungsinformationen
        """
        memory_info = {}
        
        # Grundlegende Python-Speichernutzung
        memory_info['python_alloc'] = sys.getsizeof(0)  # Basis für Messungen
        
        # GC-Informationen sammeln
        gc.collect()  # Optional: Forcierter GC
        memory_info['gc_objects'] = len(gc.get_objects())
        
        # Psutil für erweiterte System-Informationen verwenden, falls verfügbar
        if PSUTIL_AVAILABLE:
            process = psutil.Process()
            mem_info = process.memory_info()
            memory_info['rss'] = mem_info.rss  # Resident Set Size
            memory_info['vms'] = mem_info.vms  # Virtual Memory Size
            
            # Aktuelle CPU-Nutzung
            memory_info['cpu_percent'] = process.cpu_percent(interval=0.1)
            
            # Setze Peak-Memory
            if mem_info.rss > self.peak_memory:
                self.peak_memory = mem_info.rss
        
        # Snapshot mit Zeitstempel hinzufügen
        snapshot = {
            'timestamp': time.time(),
            'memory': memory_info
        }
        self.memory_snapshots.append(snapshot)
        
        # Begrenze die Anzahl der Snapshots
        if len(self.memory_snapshots) > 1000:
            self.memory_snapshots = self.memory_snapshots[-1000:]
            
        return memory_info

    def get_summary(self) -> Dict[str, Any]:
        """
        Gibt eine Zusammenfassung der Performance-Metriken zurück.

        Returns:
            Zusammenfassung aller Performance-Metriken
        """
        with self._lock:
            total_runtime = time.perf_counter() - self.start_time
            
            # Operation-Statistiken berechnen
            operation_stats = {}
            for op_name, times in self.operation_times.items():
                if not times:
                    continue
                    
                operation_stats[op_name] = {
                    'count': self.operation_counts[op_name],
                    'total_time': sum(times),
                    'avg_time': sum(times) / len(times),
                    'min_time': min(times),
                    'max_time': max(times)
                }
            
            # Memory-Statistiken
            memory_stats = {}
            if self.memory_snapshots:
                latest = self.memory_snapshots[-1]['memory']
                memory_stats = {
                    'current': latest,
                    'peak': {'rss': self.peak_memory} if PSUTIL_AVAILABLE else {}
                }
            
            return {
                'total_runtime': total_runtime,
                'operations': operation_stats,
                'memory': memory_stats,
                'timestamp': datetime.now().isoformat()
            }


@contextmanager
def measure_block(name: str, log_level: int = logging.DEBUG):
    """
    Context-Manager zum Messen eines Codeblocks.

    Args:
        name: Name des Blocks
        log_level: Log-Level für die Ausgabe
    """
    monitor = PerformanceMonitor.get_instance()
    start_time = monitor.start_operation(name)
    
    try:
        yield
    finally:
        duration = monitor.end_operation(name, start_time)
        logger.log(log_level, f"Block '{name}' ausgeführt in {duration:.4f} Sekunden")


# Alias für die Kompatibilität mit altem Code
AdvancedPerformanceMonitor = PerformanceMonitor
