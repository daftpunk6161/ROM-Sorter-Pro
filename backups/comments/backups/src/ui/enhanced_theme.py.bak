"""ROM SARTER PRO - Extended Theme Integration This module improves theme integration by ensuring that that all UI components have a uniform appearance. It monitors changes to the active theme and turns them to all registered widgets."""

import tkinter as tk
from tkinter import ttk
import os
import sys
import logging
from typing import Dict, List, Any, Optional, Set, Callable

# Logger konfigurieren
logger = logging.getLogger(__name__)

# Theme-Manager importieren
from .theme_manager import ThemeManager, Theme, ThemeType, ColorScheme
from .theme_integration import ThemeIntegrator

# Weak references for garbage collection
import weakref

# Cache for widget styles
_style_cache: Dict[str, Dict[str, Any]] = {}
_widget_registry: Set[weakref.ReferenceType] = set()
_theme_callbacks: List[Callable[[Theme], None]] = []

# Globaler Theme-Manager
_global_theme_manager = ThemeManager()


def get_current_theme() -> Theme:
    """Is the currently active theme back. Return: The current theme"""
    return _global_theme_manager.get_theme()


def apply_theme_to_widget(widget: tk.Widget, theme: Optional[Theme] = None) -> None:
    """Use a theme to a widget and his children. Args: Widget: The widget on which the theme is to be applied Theme: optional theme, by default the current theme"""
    if theme is None:
        theme = get_current_theme()

    # Apply the theme to the widget itself
    _apply_theme_to_single_widget(widget, theme)

    # Apply the theme to all children
    for child in widget.winfo_children():
        apply_theme_to_widget(child, theme)


def register_for_theme_updates(widget: tk.Widget) -> None:
    """Register a widget for automatic theme updates. Args: Widget: The widget that is to be updated in the event of changes"""
    # Use weak reference to avoid memory leaks
    _widget_registry.add(weakref.ref(widget))


def register_theme_callback(callback: Callable[[Theme], None]) -> None:
    """Register a callback that is called up when changing themes. Args: Callback: The function that is to be called"""
    _theme_callbacks.append(callback)


def set_theme(theme_name: str) -> bool:
    """Set a new theme and apply to all registered widgets. Args: Theme_Name: The name of the theme ('Light', 'Dark', 'Custom', etc.) Return: True in the event of success, false in the event of errors"""
    try:
        # Theme im Theme-Manager setzen
        if _global_theme_manager.set_active_theme(theme_name):
            # Neue Theme-Instanz abrufen
            theme = _global_theme_manager.get_theme()

            # Anwenden auf alle registrierten Widgets
            _update_all_registered_widgets(theme)

            # Callbacks aufrufen
            for callback in _theme_callbacks:
                try:
                    callback(theme)
                except Exception as e:
                    logger.error(f"Fehler im Theme-Callback: {e}")

            logger.info(f"Theme '{theme_name}' erfolgreich angewendet")
            return True
    except Exception as e:
        logger.error(f"Fehler beim Anwenden des Themes '{theme_name}': {e}")

    return False


def _update_all_registered_widgets(theme: Theme) -> None:
    """Updates all registered widgets with the new theme. Args: Theme: the user theme"""
    # Remove invalid references and update valid widgets
    global _widget_registry
    valid_refs = set()

    for widget_ref in _widget_registry:
        widget = widget_ref()
        if widget is not None:
            try:
                # Check whether the widget still exists
                widget.winfo_exists()
                apply_theme_to_widget(widget, theme)
                valid_refs.add(widget_ref)
            except Exception:
                # Widget no longer exists
                pass

    # Update the registry
    _widget_registry = valid_refs


def _apply_theme_to_single_widget(widget: tk.Widget, theme: Theme) -> None:
    """Use a theme to a single widget. Args: Widget: The widget on which the theme is to be applied Theme: the user theme"""
    try:
        widget_class = widget.__class__.__name__

        # Get the color palette
        colors = theme.get_color_scheme()

        # Common properties for all widgets
        common_props = {
            'background': colors.background,
            'foreground': colors.text
        }

        # Special properties depending on the widget type
        if widget_class in ('Button', 'TButton'):
            props = {
                'background': colors.primary,
                'foreground': '#ffffff',
                'activebackground': _adjust_color(colors.primary, 1.1),
                'activeforeground': '#ffffff',
                'relief': 'raised',
                'borderwidth': 0
            }
        elif widget_class in ('Entry', 'TEntry'):
            props = {
                'background': '#ffffff',
                'foreground': colors.text,
                'insertbackground': colors.text  # Cursor-Farbe
            }
        elif widget_class in ('Listbox', 'Treeview'):
            props = {
                'background': '#ffffff',
                'foreground': colors.text,
                'selectbackground': colors.primary,
                'selectforeground': '#ffffff'
            }
        elif widget_class in ('Frame', 'TFrame', 'Canvas'):
            props = {
                'background': colors.background
            }
        elif widget_class in ('Label', 'TLabel'):
            props = common_props
        else:
            # Standard properties for unknown widgets
            props = common_props

        # Apply the properties
        for prop, value in props.items():
            try:
                widget.configure(**{prop: value})
            except Exception:
                # Property is not supported by the widget
                pass

    except Exception as e:
        # Ignorize error for widgets that do not support certain properties
        pass


def _adjust_color(color: str, factor: float) -> str:
    """Hit a color (brighter/darker). Args: Color: Hex color code (e.g. "#3498db") Factor: factor> 1.0 for lighter, <1.0 for darker color Return: Adapted hex color code"""
    try:
        # Convert hex to rgb
        r = int(color[1:3], 16)
        g = int(color[3:5], 16)
        b = int(color[5:7], 16)

        # Passe Helligkeit an
        r = min(255, max(0, int(r * factor)))
        g = min(255, max(0, int(g * factor)))
        b = min(255, max(0, int(b * factor)))

        # Convert back to hex
        return f"#{r:02x}{g:02x}{b:02x}"
    except Exception:
        return color


def initialize_theme_system(root_widget: tk.Widget) -> None:
    """Initialized the theme system and uses the standard. Args: root_widget: The root widget of the application"""
    # Register the root widget for theme updates
    register_for_theme_updates(root_widget)

    # Apply the current theme to the root widget
    apply_theme_to_widget(root_widget)

    logger.info("Theme-System initialisiert")
