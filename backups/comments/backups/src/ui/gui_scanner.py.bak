#!/usr/bin/env python3
"""
ROM Sorter Pro - GUI Scanner Module

This module contains scanner-related functionality for the ROM Sorter Pro GUI.
"""

import logging
import os
import tkinter as tk
from tkinter import ttk, Frame, Text, Scrollbar
from threading import Thread, Event
from pathlib import Path
from datetime import datetime
import threading
import queue
import time
from concurrent.futures import ThreadPoolExecutor
import concurrent.futures

logger = logging.getLogger(__name__)


def setup_scanner_components(parent):
    """Set up scanner-related components for the GUI.

    Args:
        parent: Parent GUI instance
    """
    # Create scanner components
    create_log_widget(parent)
    create_stats_widget(parent)

    # Create and setup the scanner
    parent.scanner = FastFileScanner()

    # Initialize scanner-related attributes
    parent.scan_stats = {
        "start_time": None,
        "end_time": None,
        "total_files": 0,
        "processed_files": 0,
        "success_count": 0,
        "error_count": 0,
        "skipped_count": 0,
        "file_types": {}
    }


def create_log_widget(parent):
    """Create a log display widget. Args: Parent: Parent Gui Instance Return: Frame: The Log Widget Frame"""
    frame = Frame(parent)

    # Label
    ttk.Label(frame, text="Processing Log:").pack(anchor=tk.W, padx=5)

    # Text widget with scrollbar
    text_frame = Frame(frame)
    scrollbar = Scrollbar(text_frame)
    log_text = Text(text_frame, height=10, width=50, yscrollcommand=scrollbar.set)
    scrollbar.config(command=log_text.yview)

    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    text_frame.pack(fill=tk.BOTH, expand=True, padx=5)

    # Pack the main frame
    frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

    # Store references
    parent.components["log_widget"] = frame
    parent.components["log_text"] = log_text

    # Add logging handler
    setup_gui_logging_handler(parent, log_text)

    return frame


def create_stats_widget(parent):
    """Create a statistics display widget. Args: Parent: Parent Gui Instance Return: Frame: The Stats Widget Frame"""
    frame = Frame(parent)

    # Label
    ttk.Label(frame, text="Processing Statistics:").pack(anchor=tk.W, padx=5)

    # Stats text
    stats_text = Text(frame, height=6, width=50)
    stats_text.insert(tk.END, "No processing data available")
    stats_text.config(state=tk.DISABLED)
    stats_text.pack(fill=tk.BOTH, expand=True, padx=5)

    # Pack the main frame
    frame.pack(fill=tk.X, padx=10, pady=5)

    # Store references
    parent.components["stats_widget"] = frame
    parent.components["stats_text"] = stats_text

    return frame


def setup_gui_logging_handler(parent, log_text):
    """Set up a Handler to Redirect Logs to the GUI. Args: Parent: Parent Gui Instance Log_Text: Text Widget for Log Display"""
    class TextHandler(logging.Handler):
        def __init__(self, text_widget):
            super().__init__()
            self.text_widget = text_widget

        def emit(self, record):
            msg = self.format(record)

            def append():
                self.text_widget.config(state=tk.NORMAL)
                self.text_widget.insert(tk.END, msg + '\n')
                self.text_widget.see(tk.END)
                self.text_widget.config(state=tk.DISABLED)

            # Schedule the update in the main thread
            parent.after(0, append)

    # Create and add the handler
    text_handler = TextHandler(log_text)
    text_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    # Add to logger
    app_logger = logging.getLogger()
    app_logger.addHandler(text_handler)

    # Store reference to remove later if needed
    parent.text_log_handler = text_handler


def update_scan_stats(parent, **kwargs):
    """Update scanning statistics.

    Args:
        parent: Parent GUI instance
        **kwargs: Statistics to update
    """
    # Update stats dictionary
    for key, value in kwargs.items():
        if key in parent.scan_stats:
            parent.scan_stats[key] = value

    # Update the stats display
    if "stats_text" in parent.components:
        stats_text = parent.components["stats_text"]
        stats_text.config(state=tk.NORMAL)
        stats_text.delete(1.0, tk.END)

        # Format the stats
        lines = []
        if parent.scan_stats["start_time"]:
            lines.append(f"Started: {parent.scan_stats['start_time'].strftime('%H:%M:%S')}")

        if parent.scan_stats["end_time"]:
            lines.append(f"Finished: {parent.scan_stats['end_time'].strftime('%H:%M:%S')}")

            # Calculate duration if both start and end are available
            if parent.scan_stats["start_time"]:
                duration = parent.scan_stats["end_time"] - parent.scan_stats["start_time"]
                lines.append(f"Duration: {duration.total_seconds():.1f} seconds")

        lines.append(f"Total files: {parent.scan_stats['total_files']}")
        lines.append(f"Processed: {parent.scan_stats['processed_files']}")
        lines.append(f"Success: {parent.scan_stats['success_count']}")
        lines.append(f"Errors: {parent.scan_stats['error_count']}")
        lines.append(f"Skipped: {parent.scan_stats['skipped_count']}")

        # Add file type breakdown if any
        if parent.scan_stats["file_types"]:
            lines.append("\nFile types:")
            for ext, count in parent.scan_stats["file_types"].items():
                if count > 0:
                    lines.append(f"  {ext}: {count}")

        # Update the text widget
        stats_text.insert(tk.END, "\n".join(lines))
        stats_text.config(state=tk.DISABLED)


class FastFileScanner:
    """High-performance file scanner with optimized memory usage and adaptive performance."""

    # Class-level cache for better memory efficiency
    _scan_cache = {}
    _cache_lock = threading.RLock()
    _cache_hit_count = 0
    _cache_miss_count = 0

    # Class settings for adaptive performance
    _settings = {
        'use_threading': os.cpu_count() and os.cpu_count() > 2,
        'max_threads': max(1, min(8, (os.cpu_count() or 4) // 2)),
        'min_files_for_threading': 1000,
        'batch_size_base': 100,
        'cache_ttl': 300,  # Seconds, how long cache is valid
        'max_cache_entries': 10,
        'skip_hidden_dirs': True,
        'skip_system_dirs': True,
        'max_scan_depth': 20,  # Prevents excessively deep recursion
    }

    def __init__(self):
        """Initialize the file scanner."""
        self.stop_event = threading.Event()
        self.files_queue = queue.Queue()
        self.active_threads = 0
        self.thread_pool = None
        self.scan_thread = None

    def scan_directory(self, directory_path, recursive=True, extensions=None):
        """Scan a Directory for Files. Args: Directory_Path: Directory Path to Scan Recursive: Whether to scan subdirectories Extensions: List of File Extensions to Filter for Return: Generator Yielding File Paths"""
        # Check cache first
        cache_key = (directory_path, recursive, str(extensions))
        with self._cache_lock:
            if cache_key in self._scan_cache:
                cache_entry = self._scan_cache[cache_key]
                if time.time() - cache_entry['timestamp'] < self._settings['cache_ttl']:
                    self._cache_hit_count += 1
                    for file_path in cache_entry['files']:
                        yield file_path
                    return

        # If not in cache, perform the scan
        self._cache_miss_count += 1

        # Normalize path
        directory_path = os.path.normpath(directory_path)

        # Prepare file list
        files_list = []

        try:
            # Walk through the directory
            for current_path, dirs, files in os.walk(directory_path):
                # Skip hidden and system directories if configured
                if self._settings['skip_hidden_dirs']:
                    dirs[:] = [d for d in dirs if not d.startswith('.')]

                if self._settings['skip_system_dirs']:
                    dirs[:] = [d for d in dirs if not d.startswith('$') and d.lower() != 'system volume information']

                # Process files in this directory
                for file in files:
                    # Skip hidden files
                    if self._settings['skip_hidden_dirs'] and file.startswith('.'):
                        continue

                    # Check extension if filtering is enabled
                    if extensions:
                        file_ext = os.path.splitext(file)[1].lower()
                        if not any(file_ext.endswith(ext.lower()) for ext in extensions):
                            continue

                    # Create full path
                    file_path = os.path.join(current_path, file)
                    files_list.append(file_path)
                    yield file_path

                # Stop recursion if not enabled
                if not recursive:
                    break

        except Exception as e:
            logger.error(f"Error scanning directory {directory_path}: {e}")

        # Update cache
        with self._cache_lock:
            # Check if cache is full and remove oldest entry if needed
            if len(self._scan_cache) >= self._settings['max_cache_entries']:
                oldest_key = min(self._scan_cache, key=lambda k: self._scan_cache[k]['timestamp'])
                del self._scan_cache[oldest_key]

            # Add new entry
            self._scan_cache[cache_key] = {
                'timestamp': time.time(),
                'files': files_list
            }

    def start_scan(self, directory_path, callback, recursive=True, extensions=None):
        """Start scanning in a separate thread. Args: Directory_Path: Directory to Scan Callback: Function to Call with results Recursive: Whether to scan subdirectories Extensions: List of File Extensions to Filter for Return: True If Scan Started, False OtherWise"""
        if self.scan_thread and self.scan_thread.is_alive():
            logger.warning("A scan is already in progress")
            return False

        # Reset stop event
        self.stop_event.clear()

        # Start scan thread
        self.scan_thread = threading.Thread(
            target=self._scan_worker,
            args=(directory_path, callback, recursive, extensions),
            daemon=True
        )
        self.scan_thread.start()

        return True

    def _scan_worker(self, directory_path, callback, recursive, extensions):
        """Worker function for scanning.

        Args:
            directory_path: Directory to scan
            callback: Function to call with results
            recursive: Whether to scan subdirectories
            extensions: List of file extensions to filter for
        """
        try:
            # Initialize thread pool
            self.thread_pool = ThreadPoolExecutor(max_workers=self._settings['max_threads'])
            futures = []

            # Process files
            for file_path in self.scan_directory(directory_path, recursive, extensions):
                if self.stop_event.is_set():
                    break

                # Process file in thread pool
                future = self.thread_pool.submit(callback, file_path)
                futures.append(future)

            # Wait for all tasks to complete
            for future in concurrent.futures.as_completed(futures):
                if self.stop_event.is_set():
                    break
                try:
                    future.result()
                except Exception as e:
                    logger.error(f"Error in file processing: {e}")

        except Exception as e:
            logger.error(f"Error in scan worker: {e}")

        finally:
            # Clean up thread pool
            if self.thread_pool:
                self.thread_pool.shutdown(wait=False)
                self.thread_pool = None

    def stop_scan(self):
        """Stop any running scans."""
        self.stop_event.set()

        # Wait for scan thread to finish
        if self.scan_thread and self.scan_thread.is_alive():
            self.scan_thread.join(timeout=1.0)

        # Shutdown thread pool
        if self.thread_pool:
            self.thread_pool.shutdown(wait=False)
            self.thread_pool = None
            lines.append("\nFile types:")
            for ext, count in parent.scan_stats["file_types"].items():
                lines.append(f"  {ext}: {count}")

        # Update the text widget
        stats_text.insert(tk.END, "\n".join(lines))
        stats_text.config(state=tk.DISABLED)
