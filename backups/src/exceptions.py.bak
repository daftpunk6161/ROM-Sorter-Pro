#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ROM Sorter Pro - Konsolidierte Ausnahmeklassen

Dieses Modul enthält alle Ausnahmeklassen, die im Projekt verwendet werden,
zentral an einem Ort zusammengefasst, um Duplizierungen zu vermeiden und
die Konsistenz zu verbessern.
"""

from datetime import datetime
from typing import Dict, Any, Optional


class BaseError(Exception):
    """Basisklasse für alle projektspezifischen Fehler."""

    def __init__(self, message: str, error_code: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.error_code = error_code or "ERROR"
        self.details = details or {}
        self.timestamp = datetime.now()

    def to_dict(self) -> Dict[str, Any]:
        """Konvertiert die Ausnahme in ein Dictionary für strukturiertes Logging."""
        return {
            'error_code': self.error_code,
            'message': str(self),
            'details': self.details,
            'timestamp': self.timestamp.isoformat()
        }


# ============================================================================
# SICHERHEITSBEZOGENE FEHLER
# ============================================================================

class SecurityError(BaseError):
    """Basisklasse für sicherheitsbezogene Fehler."""

    def __init__(self, message: str, error_code: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        super().__init__(message, error_code or "SECURITY_ERROR", details)


class PathTraversalError(SecurityError):
    """Wird ausgelöst, wenn ein Path-Traversal-Angriff erkannt wird."""

    def __init__(self, message: str, path: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        path_details = details or {}
        if path:
            path_details['path'] = str(path)
        super().__init__(message, "PATH_TRAVERSAL", path_details)


class InvalidPathError(SecurityError):
    """Wird ausgelöst, wenn die Pfadvalidierung fehlschlägt."""

    def __init__(self, message: str, path: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        path_details = details or {}
        if path:
            path_details['path'] = str(path)
        super().__init__(message, "INVALID_PATH", path_details)


# ============================================================================
# KONFIGURATIONSBEZOGENE FEHLER
# ============================================================================

class ConfigurationError(BaseError):
    """Basisklasse für Konfigurationsfehler."""

    def __init__(self, message: str, error_code: Optional[str] = None,
                 file_path: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        config_details = details or {}
        if file_path:
            config_details['file_path'] = file_path
        super().__init__(message, error_code or "CONFIG_ERROR", config_details)


class ValidationError(ConfigurationError):
    """Wird ausgelöst, wenn die Konfigurationsvalidierung fehlschlägt."""

    def __init__(self, message: str, field_name: Optional[str] = None,
                 expected_type: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        validation_details = details or {}
        if field_name:
            validation_details['field_name'] = field_name
        if expected_type:
            validation_details['expected_type'] = expected_type
        super().__init__(message, "VALIDATION_ERROR", None, validation_details)


# ============================================================================
# IO UND DATENBEZOGENE FEHLER
# ============================================================================

class DataError(BaseError):
    """Basisklasse für datenbezogene Fehler."""

    def __init__(self, message: str, error_code: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        super().__init__(message, error_code or "DATA_ERROR", details)


class DatabaseError(DataError):
    """Wird ausgelöst bei Datenbankfehlern."""

    def __init__(self, message: str, query: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        db_details = details or {}
        if query:
            # Sicherstellen, dass keine sensiblen Daten im Log erscheinen
            db_details['query_type'] = query.split()[0] if query else "UNKNOWN"
        super().__init__(message, "DB_ERROR", db_details)


class FileOperationError(DataError):
    """Wird ausgelöst bei Dateioperationsfehlern."""

    def __init__(self, message: str, file_path: Optional[str] = None,
                 operation: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        file_details = details or {}
        if file_path:
            file_details['file_path'] = str(file_path)
        if operation:
            file_details['operation'] = operation
        super().__init__(message, "FILE_OP_ERROR", file_details)


# ============================================================================
# VERARBEITUNGSBEZOGENE FEHLER
# ============================================================================

class ProcessingError(BaseError):
    """Basisklasse für Fehler während der Verarbeitung von ROMs."""

    def __init__(self, message: str, error_code: Optional[str] = None,
                 rom_path: Optional[str] = None,
                 phase: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        proc_details = details or {}
        if rom_path:
            proc_details['rom_path'] = str(rom_path)
        if phase:
            proc_details['phase'] = phase
        super().__init__(message, error_code or "PROCESSING_ERROR", proc_details)


class ConsoleDetectionError(ProcessingError):
    """Wird ausgelöst, wenn die Konsolenerkennung fehlschlägt."""

    def __init__(self, message: str, rom_path: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        super().__init__(message, "CONSOLE_DETECTION_ERROR", rom_path, "detection", details)


class DuplicateHandlingError(ProcessingError):
    """Wird ausgelöst bei Fehlern während der Duplikatbehandlung."""

    def __init__(self, message: str, rom_path: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None):
        super().__init__(message, "DUPLICATE_ERROR", rom_path, "duplicate_check", details)
